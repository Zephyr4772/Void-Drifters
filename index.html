<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Void Drifters - Space Combat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a1026;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #fff;
            min-height: 100vh;
            position: relative;
        }
        /* Starfield background */
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            z-index: 0;
            pointer-events: none;
            background: repeating-radial-gradient(circle at 10% 20%, #fff 0 1px, transparent 1px 100px),
                        repeating-radial-gradient(circle at 80% 70%, #fff 0 1px, transparent 1px 120px),
                        repeating-radial-gradient(circle at 50% 50%, #fff 0 1px, transparent 1px 80px);
            opacity: 0.15;
            animation: starMove 60s linear infinite;
        }
        @keyframes starMove {
            0% { background-position: 0 0, 0 0, 0 0; }
            100% { background-position: 200px 400px, -300px 200px, 100px -200px; }
        }
        #mainMenu {
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            background: linear-gradient(135deg, #0a0a1a 0%, #0f0f23 50%, #0a1026 100%);
            overflow: hidden;
        }
        
        #mainMenu::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100vw; height: 100vh;
            z-index: 0;
            pointer-events: none;
            background: repeating-radial-gradient(circle at 10% 20%, #fff 0 1px, transparent 1px 100px),
                        repeating-radial-gradient(circle at 80% 70%, #fff 0 1px, transparent 1px 120px),
                        repeating-radial-gradient(circle at 50% 50%, #fff 0 1px, transparent 1px 80px);
            opacity: 0.15;
            animation: starMove 60s linear infinite;
        }
        
        @keyframes starMove {
            0% { background-position: 0 0, 0 0, 0 0; }
            100% { background-position: 200px 400px, -300px 200px, 100px -200px; }
        }
        
        .menuBackground {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
            pointer-events: none;
        }
        
        .menuContent {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .spaceAnimation {
            position: absolute;
            width: 100px;
            height: 100px;
            opacity: 0.3;
            animation: spaceFloat 20s linear infinite;
        }
        
        .spaceAnimation.left {
            left: 50px;
            animation-delay: 0s;
        }
        
        .spaceAnimation.right {
            right: 50px;
            animation-delay: -10s;
        }
        
        @keyframes spaceFloat {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 0.3; }
            90% { opacity: 0.3; }
            100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
        }
        
        .nebulaCloud {
            position: absolute;
            border-radius: 50%;
            opacity: 0.1;
            animation: nebulaDrift 30s linear infinite;
        }
        
        .nebulaCloud:nth-child(1) {
            width: 200px;
            height: 150px;
            background: radial-gradient(circle, rgba(120, 0, 255, 0.3), transparent);
            top: 20%;
            left: 10%;
            animation-delay: 0s;
        }
        
        .nebulaCloud:nth-child(2) {
            width: 180px;
            height: 120px;
            background: radial-gradient(circle, rgba(0, 255, 200, 0.3), transparent);
            top: 60%;
            right: 15%;
            animation-delay: -15s;
        }
        
        .nebulaCloud:nth-child(3) {
            width: 150px;
            height: 100px;
            background: radial-gradient(circle, rgba(255, 0, 150, 0.3), transparent);
            top: 40%;
            left: 80%;
            animation-delay: -7s;
        }
        
        @keyframes nebulaDrift {
            0% { transform: translateX(-100px) rotate(0deg); opacity: 0; }
            10% { opacity: 0.1; }
            90% { opacity: 0.1; }
            100% { transform: translateX(calc(100vw + 100px)) rotate(360deg); opacity: 0; }
        }
        
        .menuTitleContainer {
            text-align: center;
            margin-bottom: 4rem;
            animation: titleFloat 3s ease-in-out infinite;
        }
        
        .menuTitleImg {
            max-width: 600px;
            width: 80vw;
            filter: drop-shadow(0 0 50px #00ff88) drop-shadow(0 0 100px #00ffcc);
            animation: titleGlow 2s ease-in-out infinite alternate;
        }
        
        .menuSubtitle {
            color: #00ffcc;
            font-size: 2rem;
            letter-spacing: 4px;
            margin-top: 2rem;
            text-shadow: 0 0 20px #00ffcc;
            font-weight: 600;
            animation: subtitlePulse 2.5s ease-in-out infinite;
        }
        
        @keyframes titleGlow {
            0% { filter: drop-shadow(0 0 50px #00ff88) drop-shadow(0 0 100px #00ffcc); }
            100% { filter: drop-shadow(0 0 80px #00ff88) drop-shadow(0 0 150px #00ffcc) drop-shadow(0 0 200px #00ffff); }
        }
        
        @keyframes subtitlePulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }
        .menuButton {
            background: linear-gradient(45deg, #1a1a3a, #0f0f2a);
            color: #00ccff;
            border: 2px solid #00ccff;
            padding: 25px 40px;
            margin: 0;
            font-size: 1.3rem;
            font-weight: bold;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(0, 204, 255, 0.3), inset 0 1px 0 rgba(0, 204, 255, 0.2);
            position: relative;
            z-index: 2;
            letter-spacing: 2px;
            min-width: 250px;
            min-height: 80px;
        }
        .menuButton:hover, .menuButton:focus {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 0 30px rgba(0, 204, 255, 0.6), 0 0 50px rgba(0, 204, 255, 0.3), inset 0 1px 0 rgba(0, 204, 255, 0.4);
            background: linear-gradient(45deg, #2a2a4a, #1a1a3a);
            border-color: #00ffff;
            color: #00ffff;
        }
        
        .menuButton:active {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 0 15px rgba(0, 204, 255, 0.4), inset 0 1px 0 rgba(0, 204, 255, 0.3);
        }
        
        .menuButton span {
            font-size: 1.2em;
            margin-right: 0.5em;
        }
        .menuButtonsContainer {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            align-items: center;
            justify-items: center;
            max-width: 800px;
            margin: 0 auto;
        }
        
        @media (max-width: 768px) {
            .menuTitleImg {
                max-width: 90vw;
            }
            .menuButtonsContainer {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            .menuButton {
                padding: 20px 30px;
                font-size: 1.2rem;
                min-width: 220px;
                min-height: 70px;
            }
        }
        
        @media (max-width: 480px) {
            .menuTitleImg {
                max-width: 95vw;
            }
            .menuButton {
                padding: 18px 25px;
                font-size: 1.1rem;
                min-width: 200px;
                min-height: 65px;
            }
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #mainMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            overflow: hidden;
        }

        #mainMenu::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(120, 0, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 255, 200, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(255, 0, 150, 0.1) 0%, transparent 50%);
            animation: nebulaFloat 20s ease-in-out infinite;
        }

        @keyframes nebulaFloat {
            0%, 100% { transform: translate(0, 0) scale(1); }
            33% { transform: translate(-20px, -10px) scale(1.1); }
            66% { transform: translate(20px, 10px) scale(0.9); }
        }

        .menuTitle {
            text-align: center;
            margin-bottom: 2rem;
            position: relative;
            z-index: 2;
        }

        .menuTitle img {
            max-width: 350px;
            height: auto;
            filter: drop-shadow(0 0 30px #00ff88);
            animation: titleFloat 3s ease-in-out infinite;
        }

        @keyframes titleFloat {
            0%, 100% { 
                transform: translateY(0px);
                filter: drop-shadow(0 0 30px #00ff88);
            }
            50% { 
                transform: translateY(-10px);
                filter: drop-shadow(0 0 50px #00ff88);
            }
        }

        .menuContainer {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 2rem;
            border-radius: 20px;
            border: 2px solid rgba(0, 255, 136, 0.3);
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.2);
            max-width: 800px;
            width: 90%;
        }

        .menuSection {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            align-items: center;
        }

        .menuSectionTitle {
            color: #00ff88;
            font-size: 1rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 10px #00ff88;
        }

        .menuButton {
            background: linear-gradient(45deg, #1a1a3a, #0f0f2a);
            color: #00ccff;
            border: 2px solid #00ccff;
            padding: 12px 25px;
            margin: 4px;
            font-size: 0.95rem;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            box-shadow: 0 0 15px rgba(10, 170, 210, 0.3), inset 0 1px 0 rgba(0, 204, 255, 0.2);
            position: relative;
            z-index: 2;
            letter-spacing: 1px;
            width: 100%;
            max-width: 180px;
        }

        .menuButton::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            border-radius: 15px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .menuButton:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 0 25px rgba(0, 204, 255, 0.6), 0 0 40px rgba(0, 204, 255, 0.3), inset 0 1px 0 rgba(0, 204, 255, 0.4);
            background: linear-gradient(45deg, #2a2a4a, #1a1a3a);
            border-color: #00ffff;
            color: #00ffff;
        }

        .menuButton:hover::before {
            opacity: 1;
        }

        .menuButton:active {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 0 10px rgba(0, 204, 255, 0.4), inset 0 1px 0 rgba(0, 204, 255, 0.3);
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 30%, #0f0f0f 100%);
            cursor: none;
        }

        .nebula {
            position: absolute;
            border-radius: 50%;
            opacity: 0.1;
            animation: nebulaDrift 30s linear infinite;
        }

        @keyframes nebulaDrift {
            0% { transform: translateX(-100px) rotate(0deg); }
            100% { transform: translateX(calc(100vw + 100px)) rotate(360deg); }
        }

        .nebula:nth-child(1) {
            width: 300px;
            height: 200px;
            background: radial-gradient(circle, rgba(120, 0, 255, 0.3), transparent);
            top: 20%;
            animation-delay: 0s;
        }

        .nebula:nth-child(2) {
            width: 250px;
            height: 180px;
            background: radial-gradient(circle, rgba(0, 255, 200, 0.3), transparent);
            top: 60%;
            animation-delay: -15s;
        }

        .nebula:nth-child(3) {
            width: 200px;
            height: 150px;
            background: radial-gradient(circle, rgba(255, 0, 150, 0.3), transparent);
            top: 40%;
            animation-delay: -7s;
        }

        #spaceshipSelect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 95;
        }

        .spaceshipCard {
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 20px;
            padding: 25px;
            margin: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 200px;
            position: relative;
            overflow: hidden;
        }

        .spaceshipCard::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.2), transparent);
            transition: left 0.5s;
        }

        .spaceshipCard:hover::before {
            left: 100%;
        }

        .spaceshipCard:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        .spaceshipCard.selected {
            background: rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 40px #00ff88;
            border-color: #ffffff;
        }

        .spaceshipCard img {
            width: 100px;
            height: 100px;
            object-fit: contain;
            margin-bottom: 10px;
            filter: drop-shadow(0 0 10px #00ff88);
        }

        .spaceshipGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            max-width: 900px;
            margin: 20px;
        }

        #weaponSelect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 90;
        }

        .weaponCard {
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 20px;
            margin: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 200px;
        }

        .weaponCard:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: scale(1.05);
        }

        .weaponCard.selected {
            background: rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 20px #00ff88;
        }

        .weaponGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            max-width: 800px;
            margin: 20px;
        }

        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: none;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #weaponHUD {
            position: absolute;
            bottom: 80px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            color: #00ff88;
            font-size: 14px;
            pointer-events: all;
        }

        .weaponSlot {
            display: inline-block;
            margin: 5px;
            padding: 5px 10px;
            border: 1px solid #00ff88;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .weaponSlot.active {
            background: #00ff88;
            color: #000;
        }

        .weaponSlot:hover {
            background: rgba(0, 255, 136, 0.3);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid #00ff88;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
            display: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: #00ff88;
        }

        #crosshair::before {
            width: 2px;
            height: 30px;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 30px;
            height: 2px;
            top: 50%;
            left: -5px;
            transform: translateY(-50%);
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 18px;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            border: 2px solid #00ff88;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            border: 2px solid #ff4444;
            display: none;
            pointer-events: all;
        }

        #gameOver h1 {
            color: #ff4444;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff4444;
        }

        #gameOver p {
            font-size: 20px;
            margin-bottom: 30px;
            color: #ccc;
        }

        #restartBtn {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
        }

        #restartBtn:hover {
            background: #00cc66;
            transform: scale(1.05);
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #888;
            font-size: 14px;
            line-height: 1.4;
        }

        #powerupNotification {
            position: absolute;
            bottom: 120px;
            right: 20px;
            background: rgba(0, 255, 136, 0.8);
            color: #000;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            display: none;
            animation: powerupPulse 2s ease-out;
            max-width: 200px;
            text-align: center;
        }

        #warningAlert {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 68, 68, 0.9);
            color: #fff;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            display: none;
            animation: warningPulse 1s infinite;
        }

        @keyframes powerupPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0; }
        }

        @keyframes warningPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        @keyframes auraPulse {
            0%, 100% { 
                filter: drop-shadow(0 0 50px #00ff88) drop-shadow(0 0 100px #00ffcc) drop-shadow(0 0 150px #00ffff);
                transform: scale(1);
            }
            50% { 
                filter: drop-shadow(0 0 80px #00ff88) drop-shadow(0 0 150px #00ffcc) drop-shadow(0 0 200px #00ffff);
                transform: scale(1.05);
            }
        }

        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        #weaponStatus {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #ff8800;
            font-size: 16px;
            text-shadow: 0 0 10px #ff8800;
        }

        #comboCounter {
            position: absolute;
            bottom: 80px;
            left: 20px;
            color: #ffff00;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 0 0 10px #ffff00;
            display: none;
            pointer-events: none;
            z-index: 20;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
        }

        #bossHealth {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff0000;
            display: none;
        }

        #bossHealthBar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff8800);
            transition: width 0.3s;
        }

        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            border: 2px solid #00ff88;
            display: none;
            pointer-events: all;
            z-index: 30;
            text-align: center;
        }

        #pauseMenu h2 {
            color: #00ff88;
            margin-bottom: 20px;
        }

        #pauseMenu button {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        #pauseMenu button:hover {
            background: linear-gradient(45deg, #00cc66, #00ff88);
            transform: scale(1.05);
        }

        #credits {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .creditsContent {
            background: rgba(0, 255, 136, 0.1);
            border: 2px solid #00ff88;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            max-width: 600px;
        }

        .creditsContent h2 {
            color: #00ff88;
            font-size: 2.5rem;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #00ff88;
        }

        .creditsContent p {
            color: #ffffff;
            font-size: 1.2rem;
            margin: 15px 0;
            line-height: 1.6;
        }

        .socialLinks {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 30px;
        }

        .socialLink {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            color: #000;
            text-decoration: none;
            padding: 15px 25px;
            border-radius: 10px;
            font-weight: bold;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
        }

        .socialLink:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.5);
            background: linear-gradient(45deg, #00cc66, #00ff88);
        }

        #cheatMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .cheatGrid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            max-width: 800px;
            margin: 20px;
        }

        .cheatButton {
            background: linear-gradient(45deg, #ff4444, #cc0000);
            color: #fff;
            border: none;
            padding: 15px 20px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
        }

        .cheatButton:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 68, 68, 0.6);
            background: linear-gradient(45deg, #cc0000, #ff4444);
        }

        .cheatButton:active {
            transform: translateY(-1px) scale(1.02);
        }

        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .menuTitle img {
                max-width: 280px;
            }
            
            .menuContainer {
                grid-template-columns: 1fr;
                gap: 1.5rem;
                padding: 1.5rem;
                margin: 0 1rem;
            }
            
            .menuButton {
                padding: 12px 25px;
                font-size: 1rem;
                max-width: 200px;
            }
            
            .menuSectionTitle {
                font-size: 1rem;
            }
        }

        @media (max-width: 480px) {
            .menuTitle img {
                max-width: 220px;
            }
            
            .menuContainer {
                padding: 1rem;
                gap: 1rem;
            }
            
            .menuButton {
                padding: 10px 20px;
                font-size: 0.9rem;
                max-width: 180px;
            }
            
            .menuSectionTitle {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="mainMenu">
            <div class="menuBackground">
                <div class="nebulaCloud"></div>
                <div class="nebulaCloud"></div>
                <div class="nebulaCloud"></div>
                <div class="spaceAnimation left">🪨</div>
                <div class="spaceAnimation right">👽</div>
                <div class="spaceAnimation left">🪨</div>
                <div class="spaceAnimation right">👽</div>
                <div class="spaceAnimation left">🪨</div>
                <div class="spaceAnimation right">👽</div>
            </div>
            <div class="menuContent">
                <div class="menuTitleContainer">
                    <img src="title.png" alt="Void Drifters" class="menuTitleImg">
                </div>
                <div class="menuButtonsContainer">
                    <button class="menuButton" id="startBtn"><span>🚀</span>START GAME</button>
                    <button class="menuButton" id="spaceshipSelectBtn"><span>🛸</span> SPACESHIP</button>
                    <button class="menuButton" id="weaponSelectBtn"><span>🔫</span> WEAPONS</button>
                    <button class="menuButton" id="creditsBtn"><span>🏆</span>CREDITS</button>
                </div>
            </div>
        </div>
        
        <div id="spaceshipSelect">
            <h2 style="color: #00ff88; margin-bottom: 20px; font-size: 2.5rem;">SELECT YOUR SPACESHIP</h2>
            <div class="spaceshipGrid">
                <div class="spaceshipCard selected" data-spaceship="spaceships/spaceship.png">
                    <img src="spaceships/spaceship.png" alt="Spaceship 1">
                    <h3>Interceptor</h3>
                    <p>Balanced fighter with good speed and firepower</p>
                    <p>Speed: Medium | Durability: Medium</p>
                </div>
                <div class="spaceshipCard" data-spaceship="spaceships/spaceship2.png">
                    <img src="spaceships/spaceship2.png" alt="Spaceship 2">
                    <h3>Striker</h3>
                    <p>Heavy assault ship with maximum firepower</p>
                    <p>Speed: Low | Durability: High</p>
                </div>
                <div class="spaceshipCard" data-spaceship="spaceships/spaceship3.png">
                    <img src="spaceships/spaceship3.png" alt="Spaceship 3">
                    <h3>Scout</h3>
                    <p>Lightweight reconnaissance vessel</p>
                    <p>Speed: High | Durability: Low</p>
                </div>
                <div class="spaceshipCard" data-spaceship="spaceships/spaceship4.png">
                    <img src="spaceships/spaceship4.png" alt="Spaceship 4">
                    <h3>Guardian</h3>
                    <p>Defensive ship with enhanced shields</p>
                    <p>Speed: Medium | Durability: Very High</p>
                </div>
                <div class="spaceshipCard" data-spaceship="spaceships/spaceship5.png">
                    <img src="spaceships/spaceship5.png" alt="Spaceship 5">
                    <h3>Phantom</h3>
                    <p>Stealth fighter with advanced systems</p>
                    <p>Speed: Very High | Durability: Medium</p>
                </div>
            </div>
            <button class="menuButton" id="confirmSpaceship">CONFIRM SELECTION</button>
            <button class="menuButton" id="backToMenuFromShip">BACK TO MENU</button>
        </div>

        <div id="weaponSelect">
            <h2 style="color: #00ff88; margin-bottom: 20px;">SELECT YOUR WEAPONS</h2>
            <div class="weaponGrid">
                <div class="weaponCard" data-weapon="normal">
                    <h3>Normal Gun</h3>
                    <p>Single bullet rapid fire</p>
                    <p>Damage: 15 | Fire Rate: High</p>
                </div>
                <div class="weaponCard" data-weapon="dual">
                    <h3>Dual Guns</h3>
                    <p>Two parallel bullets</p>
                    <p>Damage: 12x2 | Fire Rate: High</p>
                </div>
                <div class="weaponCard" data-weapon="laser">
                    <h3>Laser Beam</h3>
                    <p>Continuous laser stream</p>
                    <p>Damage: 8/sec | Continuous</p>
                </div>
                <div class="weaponCard" data-weapon="shotgun">
                    <h3>Shotgun</h3>
                    <p>Burst of 4 random bullets</p>
                    <p>Damage: 8x4 | Fire Rate: Medium</p>
                </div>
            </div>
            <button class="menuButton" id="confirmWeapons">CONFIRM SELECTION</button>
            <button class="menuButton" id="backToMenu">BACK TO MENU</button>
        </div>

        <!-- Hidden cheat input -->
        <input type="text" id="cheatInput" style="position: absolute; top: -100px; left: -100px; opacity: 0; pointer-events: none;">
        
        <div id="cheatMenu">
            <div class="creditsContent">
                <h2>CHEAT MENU</h2>
                <p>Unlock powerful abilities and modifications</p>
                <div class="cheatGrid">
                    <button class="cheatButton" id="godModeBtn">GOD MODE</button>
                    <button class="cheatButton" id="infiniteAmmoBtn">INFINITE AMMO</button>
                    <button class="cheatButton" id="maxLivesBtn">MAX LIVES</button>
                    <button class="cheatButton" id="maxFuelBtn">MAX FUEL</button>
                    <button class="cheatButton" id="maxShieldBtn">MAX SHIELD</button>
                    <button class="cheatButton" id="addScoreBtn">ADD 10000 SCORE</button>
                    <button class="cheatButton" id="spawnBossBtn">SPAWN BOSS</button>
                    <button class="cheatButton" id="clearEnemiesBtn">CLEAR ENEMIES</button>
                    <button class="cheatButton" id="allWeaponsBtn">UNLOCK ALL WEAPONS</button>
                    <button class="cheatButton" id="rapidFireBtn">RAPID FIRE</button>
                    <button class="cheatButton" id="freeRoamBtn">FREE ROAM</button>
                    <button class="cheatButton" id="onlyAsteroidsBtn">ONLY ASTEROIDS</button>
                    <button class="cheatButton" id="onlyAliensBtn">ONLY ALIENS</button>
                    <button class="cheatButton" id="bossModeBtn">BOSS MODE</button>
                    <button class="cheatButton" id="showcaseBtn">SHOWCASE</button>
                    <button class="cheatButton" id="normalModeBtn" style="background: linear-gradient(45deg, #00ff88, #00cc66); color: #000;">RETURN TO NORMAL</button>
                </div>
                <button class="menuButton" id="closeCheatMenu" style="margin-top: 30px;">CLOSE CHEAT MENU</button>
            </div>
        </div>

        <div id="credits">
            <div class="creditsContent">
                <h2>VOID DRIFTERS</h2>
                <p>A space combat game made by Sinhal Joshi</p>
                <p>After Deescalatting and Preventing The 9/11 Mr. Joshi has Taken Intrest To Resolve Galactic Wars</p>
                <p>With His Wast Fortune He Now Roams The Galaxy With His Fleet Of Spaceships Looking For Any Racist Aliens,After He Find One, He Kills Them And Fuck THeir Wives So Thier Kids Know Not To Follow In Daddy's Footsteps</p>
                <div class="socialLinks">
                    <a href="https://github.com/Zephyr4772" target="_blank" class="socialLink">GitHub</a>
                    <a href="https://www.linkedin.com/in/sinhal-joshi-244603275/" target="_blank" class="socialLink">LinkedIn</a>
                </div>
                <button class="menuButton" id="backToMenuFromCredits" style="margin-top: 30px;">BACK TO MENU</button>
            </div>
        </div>
        
        <div id="gameUI">
            <div id="hud">
                <div>Score: <span id="score">0</span></div>
                <div>Level: <span id="level">1</span></div>
                <div>Lives: <span id="lives">3</span></div>
                <div>Fuel: <span id="fuel">100</span>%</div>
                <div>Shield: <span id="shield">0</span></div>
                <div>Aliens: <span id="alienCount">0</span></div>
                <div>Weapon: <span id="activeWeapon">Laser</span> (<span id="weaponAmmo">500</span>)</div>
            </div>
            

            
            <div id="instructions">
                WASD or Arrow Keys: Move | Shift: Thruster Boost | Left Click: Fire Weapon<br>
                Avoid asteroids and aliens! Collect power-ups to survive!
            </div>
            
            <div id="weaponStatus">
                <div>Ammo: <span id="ammo">500</span></div>
                <div>Weapon: <span id="weaponType">Laser</span></div>
                <div>Combo: <span id="combo">0</span>x</div>
            </div>
            

            
            <div id="powerupNotification"></div>
            <div id="warningAlert">⚠️ ALIEN SHIPS DETECTED ⚠️</div>
            <div id="comboCounter"></div>
            
            <div id="bossHealth">
                <div id="bossHealthBar"></div>
            </div>
            

            
            <div id="pauseMenu">
                <h2>GAME PAUSED</h2>
                <button id="resumeBtn">RESUME</button>
                <button id="restartPauseBtn">RESTART</button>
                <button id="quitBtn">QUIT</button>
            </div>
        </div>
        
        <div id="gameOver">
            <h1>GAME OVER</h1>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Level Reached: <span id="finalLevel">1</span></p>
            <p>Aliens Defeated: <span id="aliensKilled">0</span></p>
            <button id="restartBtn">RESTART MISSION</button>
        </div>
    </div>

    <script>
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                this.gameState = 'menu';
                this.score = 0;
                this.level = 1;
                this.lives = 10;
                this.maxLives = 10;
                this.fuel = 100;
                this.shield = 100; // Start with full shield
                this.ammo = { normal: 500, dual: 500, shotgun: 500 };
                this.weaponType = 'normal';
                this.aliensKilled = 0;
                this.combo = 0;
                this.comboTimer = 0;
                this.lastKillTime = 0;
                this.bossActive = false;
                this.boss = null;
                this.bossStage = 0; // Track boss progression
                this.bossSpawnCooldown = 0; // Boss spawn cooldown timer
                this.lastBossSpawnTime = 0; // Track when last boss was spawned
                this.bossSpawnInterval = 60000; // 30 seconds minimum between bosses
                this.bossSpawnCooldown = 0; // Boss spawn cooldown timer
                this.lastBossSpawnTime = 0; // Track when last boss was spawned
                this.bossSpawnInterval = 60000; // 30 seconds minimum between bosses
                
                // Weapon system
                this.weapons = ['normal', 'dual', 'shotgun'];
                this.currentWeaponIndex = 0;
                this.weaponCooldowns = { normal: 0, dual: 0, shotgun: 0 };
                this.isMouseDown = false;
                this.mouseX = 0;
                this.mouseY = 0;
                
                // Cheat system
                this.godMode = false;
                this.infiniteAmmo = false;
                this.rapidFire = false;
                this.cheatInput = '';
                this.cheatTimer = 0;
                
                // Sound effects
                this.sounds = {};
                this.initSounds();
                
                // Background music
                this.backgroundMusic = null;
                this.initBackgroundMusic();
                
                this.keys = {};
                
                this.selectedSpaceship = 'spaceships/spaceship.png';
                this.spaceship = new Spaceship(this.canvas.width / 2, this.canvas.height / 2, this.selectedSpaceship);
                this.asteroids = [];
                this.aliens = [];
                this.shootingAliens = [];
                this.explodingAliens = [];
                this.multiplyingAliens = [];
                this.powerups = [];
                this.particles = [];
                this.stars = [];
                this.projectiles = [];
                this.enemyProjectiles = [];
                
                this.lastTime = 0;
                this.asteroidSpawnTimer = 0;
                this.alienSpawnTimer = 0;
                this.shootingAlienSpawnTimer = 0;
                this.explodingAlienSpawnTimer = 0;
                this.multiplyingAlienSpawnTimer = 0;
                this.powerupSpawnTimer = 0;
                this.fuelDecayTimer = 0;
                this.warningTimer = 0;
                this.showWarning = false;
                
                this.initializeStars();
                this.setupEventListeners();
                // Don't spawn objects or start game loop until game starts
                // this.spawnInitialObjects();
                // this.gameLoop();
            }
            
            initSounds() {
                // Create audio context for sound effects
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not supported');
                    return;
                }
            }
            
            initBackgroundMusic() {
                try {
                    this.backgroundMusic = new Audio('background.mp3');
                    this.backgroundMusic.loop = true;
                    this.backgroundMusic.volume = 0.3;
                } catch (e) {
                    console.log('Background music not available');
                }
            }
            
            startGame() {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('gameUI').style.display = 'block';
                this.gameState = 'playing';
                
                // Create new spaceship with selected image
                console.log('Creating spaceship with image:', this.selectedSpaceship);
                this.spaceship = new Spaceship(this.canvas.width / 2, this.canvas.height / 2, this.selectedSpaceship);
                
                // Initialize game objects and start game loop
                this.spawnInitialObjects();
                this.gameLoop();
                
                if (this.backgroundMusic) {
                    this.backgroundMusic.play().catch(e => console.log('Music autoplay blocked'));
                }
            }
            
            showSpaceshipSelect() {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('spaceshipSelect').style.display = 'flex';
            }
            
            showWeaponSelect() {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('weaponSelect').style.display = 'flex';
            }
            
            showMainMenu() {
                document.getElementById('spaceshipSelect').style.display = 'none';
                document.getElementById('weaponSelect').style.display = 'none';
                document.getElementById('credits').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            }
            
            showInstructions() {
                alert(`VOID DRIFTERS - INSTRUCTIONS

CONTROLS:
- WASD or Arrow Keys: Move ship
- Space: Boost
- Left Click: Fire weapon
- Hold Left Click: Rapid fire
- 1,2,3: Switch weapon slots
- Escape: Pause game

OBJECTIVE:
- Survive as long as possible
- Destroy asteroids and alien ships
- Collect power-ups
- Build combos for bonus points
- Defeat bosses every 5 levels

WEAPONS:
- Laser: Fast, accurate single shot
- Plasma: Powerful energy projectile
- Dual Guns: Twin rapid-fire cannons
- Burst Fire: Three-shot burst
- Missile: Homing explosive projectile
- Shotgun: Wide spread damage

GOOD LUCK, PILOT!`);
            }
            
            showCredits() {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('credits').style.display = 'flex';
            }
            
            showCheatMenu() {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('cheatMenu').style.display = 'flex';
            }
            
            hideCheatMenu() {
                document.getElementById('cheatMenu').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            }
            
            checkCheatCode(key) {
                this.cheatInput += key.toLowerCase();
                this.cheatTimer = 0;
                
                // Check if "cheat" is typed
                if (this.cheatInput.includes('cheat')) {
                    this.showCheatMenu();
                    this.cheatInput = '';
                    return;
                }
                
                // Check if "lore" is typed
                if (this.cheatInput.includes('lore')) {
                    this.showRollingCredits();
                    this.cheatInput = '';
                    return;
                }
                
                // Reset input if it gets too long
                if (this.cheatInput.length > 20) {
                    this.cheatInput = '';
                }
            }
            
            // Cheat functions
            toggleGodMode() {
                this.godMode = !this.godMode;
                if (this.godMode) {
                    this.lives = 999;
                    this.shield = 100;
                    this.showNotification('GOD MODE ACTIVATED!');
                } else {
                    this.lives = Math.min(this.lives, 20);
                    this.showNotification('GOD MODE DEACTIVATED!');
                }
            }
            
            toggleInfiniteAmmo() {
                this.infiniteAmmo = !this.infiniteAmmo;
                if (this.infiniteAmmo) {
                    this.ammo = 999;
                    this.showNotification('INFINITE AMMO ACTIVATED!');
                } else {
                    this.ammo = Math.min(this.ammo, 200);
                    this.showNotification('INFINITE AMMO DEACTIVATED!');
                }
            }
            
            maxLives() {
                this.lives = 20;
                this.maxLives = 20;
                this.showNotification('MAX LIVES RESTORED!');
            }
            
            maxFuel() {
                this.fuel = 100;
                this.showNotification('FUEL RESTORED TO MAX!');
            }
            
            maxShield() {
                this.shield = 100;
                this.showNotification('SHIELD RESTORED TO MAX!');
            }
            
            addScore() {
                this.score += 10000;
                this.showNotification('+10000 SCORE ADDED!');
            }
            
            spawnBoss() {
                const currentTime = performance.now();
                
                // Check if enough time has passed since last boss
                if (currentTime - this.lastBossSpawnTime < this.bossSpawnInterval) {
                    const remainingTime = Math.ceil((this.bossSpawnInterval - (currentTime - this.lastBossSpawnTime)) / 1000);
                    this.showNotification(`BOSS COOLDOWN: ${remainingTime}s remaining`);
                    return false;
                }
                
                this.bossActive = true;
                this.bossStage = (this.bossStage || 0) + 1;
                if (this.bossStage > 5) this.bossStage = 5;
                this.boss = new Boss(this.canvas.width / 2, -100, this.level, this.bossStage);
                this.lastBossSpawnTime = currentTime;
                
                document.getElementById('bossHealth').style.display = 'block';
                
                // Show stage-specific boss announcement
                let bossName = '';
                let bossColor = '#ff0000';
                switch(this.bossStage) {
                    case 1:
                        bossName = 'SCOUT DRONE';
                        bossColor = '#ff0000';
                        break;
                    case 2:
                        bossName = 'WARRIOR CLASS';
                        bossColor = '#ff6600';
                        break;
                    case 3:
                        bossName = 'COMMANDER';
                        bossColor = '#ff00ff';
                        break;
                    case 4:
                        bossName = 'DESTROYER';
                        bossColor = '#ff0088';
                        break;
                    case 5:
                        bossName = 'LEVIATHAN';
                        bossColor = '#ff0000';
                        break;
                }
                
                this.showBossWarning(bossName, bossColor);
                return true;
            }
            
            checkLaserCollisions() {
                if (!this.laserActive || !this.laserStartX) return;
                
                // Check laser collision with asteroids
                this.asteroids.forEach((asteroid, index) => {
                    if (this.lineIntersectsCircle(this.laserStartX, this.laserStartY, this.laserEndX, this.laserEndY, asteroid.x, asteroid.y, asteroid.size)) {
                        this.createExplosion(asteroid.x, asteroid.y);
                        this.asteroids.splice(index, 1);
                        this.score += 100;
                        this.playSound('hit');
                    }
                });
                
                // Check laser collision with aliens
                this.aliens.forEach((alien, index) => {
                    if (this.lineIntersectsCircle(this.laserStartX, this.laserStartY, this.laserEndX, this.laserEndY, alien.x, alien.y, alien.size)) {
                        this.createExplosion(alien.x, alien.y, '#ff0000');
                        this.aliens.splice(index, 1);
                        
                        // Combo system
                        const currentTime = performance.now();
                        if (currentTime - this.lastKillTime < 3000) {
                            this.combo++;
                            this.comboTimer = 0;
                            const comboBonus = this.combo * 100;
                            this.score += 500 + comboBonus;
                            this.showCombo(this.combo, comboBonus);
                        } else {
                            this.combo = 1;
                            this.comboTimer = 0;
                            this.score += 500;
                        }
                        this.lastKillTime = currentTime;
                        this.aliensKilled++;
                        this.showNotification('ALIEN DESTROYED! +500 POINTS');
                        this.ammo[this.weaponType] = Math.min(200, (this.ammo[this.weaponType] ?? 0) + 100);
                        this.lives = Math.min(this.maxLives, this.lives + 1);
                        this.updateUI();
                        this.playSound('hit');
                    }
                });
                
                // Check laser collision with shooting aliens
                this.shootingAliens.forEach((alien, index) => {
                    if (this.lineIntersectsCircle(this.laserStartX, this.laserStartY, this.laserEndX, this.laserEndY, alien.x, alien.y, alien.size)) {
                        this.createExplosion(alien.x, alien.y, '#ff6600');
                        this.shootingAliens.splice(index, 1);
                        this.score += 600;
                        this.aliensKilled++;
                        this.showNotification('SHOOTING ALIEN DESTROYED! +600 POINTS');
                        this.ammo[this.weaponType] = Math.min(200, (this.ammo[this.weaponType] ?? 0) + 100);
                        this.lives = Math.min(this.maxLives, this.lives + 1);
                        this.updateUI();
                        this.playSound('hit');
                    }
                });
                
                // Check laser collision with exploding aliens
                this.explodingAliens.forEach((alien, index) => {
                    if (this.lineIntersectsCircle(this.laserStartX, this.laserStartY, this.laserEndX, this.laserEndY, alien.x, alien.y, alien.size)) {
                        this.createExplosion(alien.x, alien.y, '#ff0000', 40);
                        this.explodingAliens.splice(index, 1);
                        this.score += 700;
                        this.aliensKilled++;
                        this.showNotification('EXPLODING ALIEN DESTROYED! +700 POINTS');
                        this.ammo[this.weaponType] = Math.min(200, (this.ammo[this.weaponType] ?? 0) + 100);
                        this.lives = Math.min(this.maxLives, this.lives + 1);
                        this.updateUI();
                        this.playSound('hit');
                    }
                });
                
                // Check laser collision with multiplying aliens
                this.multiplyingAliens.forEach((alien, index) => {
                    if (this.lineIntersectsCircle(this.laserStartX, this.laserStartY, this.laserEndX, this.laserEndY, alien.x, alien.y, alien.size)) {
                        this.createExplosion(alien.x, alien.y, '#ff00ff');
                        this.multiplyingAliens.splice(index, 1);
                        
                        // Spawn smaller aliens when multiplying alien is destroyed
                        for (let i = 0; i < 3; i++) {
                            const smallAlien = new Alien(alien.x + (Math.random() - 0.5) * 50, alien.y + (Math.random() - 0.5) * 50);
                            smallAlien.size = 12;
                            this.aliens.push(smallAlien);
                        }
                        
                        this.score += 800;
                        this.aliensKilled++;
                        this.showNotification('MULTIPLYING ALIEN DESTROYED! +800 POINTS');
                        this.ammo[this.weaponType] = Math.min(200, (this.ammo[this.weaponType] ?? 0) + 100);
                        this.lives = Math.min(this.maxLives, this.lives + 1);
                        this.updateUI();
                        this.playSound('hit');
                    }
                });
                
                // Check laser collision with boss
                if (this.bossActive && this.boss) {
                    if (this.lineIntersectsCircle(this.laserStartX, this.laserStartY, this.laserEndX, this.laserEndY, this.boss.x, this.boss.y, this.boss.size)) {
                        if (this.boss.takeDamage(15)) { // Laser damage per frame
                            // Boss defeated
                            this.createExplosion(this.boss.x, this.boss.y, '#ff0000', 50);
                            this.score += 5000;
                            this.showNotification('BOSS DEFEATED! +5000 POINTS!');
                            this.bossActive = false;
                            this.boss = null;
                            document.getElementById('bossHealth').style.display = 'none';
                            if (this.gameState === 'playing') {
                                setTimeout(() => {
                                    if (this.gameState === 'playing' && !this.bossActive) {
                                        this.spawnBoss();
                                    }
                                }, 3000);
                            }
                        }
                        this.playSound('hit');
                    }
                }
            }
            
            lineIntersectsCircle(x1, y1, x2, y2, cx, cy, r) {
                // Check if a line segment intersects with a circle
                const dx = x2 - x1;
                const dy = y2 - y1;
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length === 0) return false;
                
                const unitX = dx / length;
                const unitY = dy / length;
                
                const t = ((cx - x1) * unitX + (cy - y1) * unitY);
                const closestX = x1 + t * unitX;
                const closestY = y1 + t * unitY;
                
                if (t < 0) {
                    closestX = x1;
                    closestY = y1;
                } else if (t > length) {
                    closestX = x2;
                    closestY = y2;
                }
                
                const distance = Math.sqrt((cx - closestX) * (cx - closestX) + (cy - closestY) * (cy - closestY));
                return distance <= r;
            }
            
            clearEnemies() {
                this.aliens = [];
                this.shootingAliens = [];
                this.explodingAliens = [];
                this.multiplyingAliens = [];
                this.asteroids = [];
                this.enemyProjectiles = [];
                this.showNotification('ALL ENEMIES CLEARED!');
            }
            
            unlockAllWeapons() {
                this.weapons = ['normal', 'dual', 'laser', 'shotgun'];
                this.showNotification('ALL WEAPONS UNLOCKED!');
            }
            
            toggleRapidFire() {
                this.rapidFire = !this.rapidFire;
                if (this.rapidFire) {
                    this.showNotification('RAPID FIRE ACTIVATED!');
                } else {
                    this.showNotification('RAPID FIRE DEACTIVATED!');
                }
            }
            
            selectSpaceship(card) {
                document.querySelectorAll('.spaceshipCard').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
            }
            
            selectWeapon(card) {
                document.querySelectorAll('.weaponCard').forEach(c => c.classList.remove('selected'));
                card.classList.add('selected');
            }
            
            selectWeaponSlot(slot) {
                this.currentWeaponIndex = parseInt(slot.dataset.slot) - 1;
                this.updateWeaponDisplay();
            }
            
            confirmSpaceshipSelection() {
                const selectedSpaceship = document.querySelector('.spaceshipCard.selected');
                if (selectedSpaceship) {
                    this.selectedSpaceship = selectedSpaceship.dataset.spaceship;
                    console.log('Selected spaceship:', this.selectedSpaceship);
                    document.getElementById('spaceshipSelect').style.display = 'none';
                    this.showMainMenu();
                }
            }
            
            confirmWeaponSelection() {
                const selectedWeapons = document.querySelectorAll('.weaponCard.selected');
                if (selectedWeapons.length === 0) {
                    alert('Please select at least one weapon!');
                    return;
                }
                
                this.weapons = Array.from(selectedWeapons).map(card => card.dataset.weapon);
                document.getElementById('weaponSelect').style.display = 'none';
                this.startGame();
            }
            
            switchWeapon(index) {
                if (index >= 0 && index < this.weapons.length) {
                    this.currentWeaponIndex = index;
                    this.updateWeaponDisplay();
                }
            }
            
            updateWeaponDisplay() {
                // Update weapon display with colors
                const weaponColors = {
                    'normal': '#00eaff', // Cyan
                    'dual': '#00ff88',   // Green
                    'shotgun': '#ff8800' // Orange
                };
                
                const weaponNames = {
                    'normal': 'Normal',
                    'dual': 'Dual',
                    'shotgun': 'Shotgun'
                };
                
                // Update active weapon display
                const currentWeapon = this.weapons[this.currentWeaponIndex];
                const activeWeaponElement = document.getElementById('activeWeapon');
                const weaponAmmoElement = document.getElementById('weaponAmmo');
                
                if (activeWeaponElement && currentWeapon) {
                    activeWeaponElement.textContent = weaponNames[currentWeapon];
                    activeWeaponElement.style.color = weaponColors[currentWeapon];
                    activeWeaponElement.style.textShadow = `0 0 10px ${weaponColors[currentWeapon]}`;
                }
                
                if (weaponAmmoElement) {
                    weaponAmmoElement.textContent = Math.floor(this.ammo[currentWeapon] ?? 0);
                }
            }
            
            playSound(type) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                switch(type) {
                    case 'shoot':
                        oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        oscillator.start(this.audioContext.currentTime);
                        oscillator.stop(this.audioContext.currentTime + 0.1);
                        break;
                    case 'explosion':
                        oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        oscillator.start(this.audioContext.currentTime);
                        oscillator.stop(this.audioContext.currentTime + 0.3);
                        break;
                    case 'powerup':
                        oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.2);
                        oscillator.type = 'sine';
                        gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        oscillator.start(this.audioContext.currentTime);
                        oscillator.stop(this.audioContext.currentTime + 0.2);
                        break;
                    case 'hit':
                        oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 0.1);
                        oscillator.type = 'triangle';
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        oscillator.start(this.audioContext.currentTime);
                        oscillator.stop(this.audioContext.currentTime + 0.1);
                        break;
                }
            }
            
            initializeStars() {
                for (let i = 0; i < 300; i++) {
                    this.stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        size: Math.random() * 2 + 0.5,
                        brightness: Math.random() * 0.8 + 0.2,
                        twinkle: Math.random() * Math.PI * 2,
                        speed: Math.random() * 0.5 + 0.1
                    });
                }
            }
            
            setupEventListeners() {
                // Menu event listeners
                document.getElementById('startBtn').addEventListener('click', () => {
                    if (!window.game) window.game = new Game();
                    window.game.startGame();
                });
                
                document.getElementById('spaceshipSelectBtn').addEventListener('click', () => {
                    this.showSpaceshipSelect();
                });
                
                document.getElementById('weaponSelectBtn').addEventListener('click', () => {
                    this.showWeaponSelect();
                });
                

                
                document.getElementById('creditsBtn').addEventListener('click', () => {
                    this.showCredits();
                });
                

                

                
                document.getElementById('confirmWeapons').addEventListener('click', () => {
                    this.confirmWeaponSelection();
                });
                
                document.getElementById('backToMenu').addEventListener('click', () => {
                    this.showMainMenu();
                });
                
                document.getElementById('confirmSpaceship').addEventListener('click', () => {
                    this.confirmSpaceshipSelection();
                });
                
                document.getElementById('backToMenuFromShip').addEventListener('click', () => {
                    this.showMainMenu();
                });
                
                document.getElementById('backToMenuFromCredits').addEventListener('click', () => {
                    this.showMainMenu();
                });
                
                document.getElementById('closeCheatMenu').addEventListener('click', () => {
                    this.hideCheatMenu();
                });
                
                // Cheat button event listeners
                document.getElementById('godModeBtn').addEventListener('click', () => {
                    this.toggleGodMode();
                });
                
                document.getElementById('infiniteAmmoBtn').addEventListener('click', () => {
                    this.toggleInfiniteAmmo();
                });
                
                document.getElementById('maxLivesBtn').addEventListener('click', () => {
                    this.maxLives();
                });
                
                document.getElementById('maxFuelBtn').addEventListener('click', () => {
                    this.maxFuel();
                });
                
                document.getElementById('maxShieldBtn').addEventListener('click', () => {
                    this.maxShield();
                });
                
                document.getElementById('addScoreBtn').addEventListener('click', () => {
                    this.addScore();
                });
                
                document.getElementById('spawnBossBtn').addEventListener('click', () => {
                    this.spawnBoss();
                });
                
                document.getElementById('clearEnemiesBtn').addEventListener('click', () => {
                    this.clearEnemies();
                });
                
                document.getElementById('allWeaponsBtn').addEventListener('click', () => {
                    this.unlockAllWeapons();
                });
                
                document.getElementById('rapidFireBtn').addEventListener('click', () => {
                    this.toggleRapidFire();
                });
                
                document.getElementById('freeRoamBtn').addEventListener('click', () => { this.setGameMode('freeRoam'); });
                document.getElementById('onlyAsteroidsBtn').addEventListener('click', () => { this.setGameMode('onlyAsteroids'); });
                document.getElementById('onlyAliensBtn').addEventListener('click', () => { this.setGameMode('onlyAliens'); });
                document.getElementById('bossModeBtn').addEventListener('click', () => { this.setGameMode('bossMode'); });
                document.getElementById('showcaseBtn').addEventListener('click', () => { this.setGameMode('showcase'); });
                document.getElementById('normalModeBtn').addEventListener('click', () => { this.setGameMode('normal'); });
                
                // Spaceship selection
                // Spaceship selection
                document.querySelectorAll('.spaceshipCard').forEach(card => {
                    card.addEventListener('click', () => {
                        this.selectSpaceship(card);
                    });
                });
                
                // Weapon selection
                document.querySelectorAll('.weaponCard').forEach(card => {
                    card.addEventListener('click', () => {
                        this.selectWeapon(card);
                    });
                });
                

                
                                // Game controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    
                    // Check for cheat codes
                    this.checkCheatCode(e.key);
                    
                    // Pause game with Escape key
                    if (e.key === 'Escape') {
                        if (this.gameMode === 'showcase') {
                            // Return from showcase mode
                            this.gameState = 'playing';
                            this.gameMode = 'normal';
                            this.render = this.originalRender;
                            this.showNotification('RETURNED TO NORMAL MODE!');
                        } else if (this.gameMode && this.gameMode !== 'normal') {
                            // Return to normal mode if in a cheat mode
                            this.setGameMode('normal');
                        } else {
                            this.togglePause();
                        }
                    }
                    
                    // Weapon switching
                    if (e.key >= '1' && e.key <= '3') {
                        this.switchWeapon(parseInt(e.key) - 1);
                    }
                });
                
                // Mouse controls
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isMouseDown = true;
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                });
                
                this.canvas.addEventListener('mouseup', (e) => {
                    this.isMouseDown = false;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    this.mouseX = e.clientX;
                    this.mouseY = e.clientY;
                });
                
                // Mouse click to fire (single shot)
                this.canvas.addEventListener('click', (e) => {
                    if (this.gameState === 'playing' && this.ammo[this.weaponType] > 0) {
                        this.fireWeapon();
                        this.playSound('shoot');
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                });
                
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restart();
                });
                
                // Pause menu event listeners
                document.getElementById('resumeBtn').addEventListener('click', () => {
                    this.togglePause();
                });
                
                document.getElementById('restartPauseBtn').addEventListener('click', () => {
                    this.restart();
                });
                
                document.getElementById('quitBtn').addEventListener('click', () => {
                    this.gameState = 'menu';
                    document.getElementById('pauseMenu').style.display = 'none';
                    this.showMainMenu();
                });
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                });
                
                // Global keydown listener for cheats (works in any game state)
                window.addEventListener('keydown', (e) => {
                    // Check for cheat codes globally - only if game instance exists
                    if (window.game && window.game.checkCheatCode) {
                        window.game.checkCheatCode(e.key);
                    }
                });
            }
            
            spawnInitialObjects() {
                // Spawn fewer initial asteroids
                for (let i = 0; i < 5; i++) {
                    this.spawnAsteroid();
                }
                
                // Spawn first alien after 15 seconds
                setTimeout(() => {
                    this.spawnAlien();
                }, 15000);
            }
            
            spawnAsteroid() {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(side) {
                    case 0: // top
                        x = Math.random() * this.canvas.width;
                        y = -50;
                        break;
                    case 1: // right
                        x = this.canvas.width + 50;
                        y = Math.random() * this.canvas.height;
                        break;
                    case 2: // bottom
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 50;
                        break;
                    case 3: // left
                        x = -50;
                        y = Math.random() * this.canvas.height;
                        break;
                }
                
                const asteroid = new Asteroid(x, y, this.level);
                this.asteroids.push(asteroid);
            }
            
            spawnAlien() {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(side) {
                    case 0: // top
                        x = Math.random() * this.canvas.width;
                        y = -50;
                        break;
                    case 1: // right
                        x = this.canvas.width + 50;
                        y = Math.random() * this.canvas.height;
                        break;
                    case 2: // bottom
                        x = Math.random() * this.canvas.width;
                        y = this.canvas.height + 50;
                        break;
                    case 3: // left
                        x = -50;
                        y = Math.random() * this.canvas.height;
                        break;
                }
                
                const alien = new Alien(x, y);
                this.aliens.push(alien);
                
                // Show warning
                this.showWarning = true;
                document.getElementById('warningAlert').style.display = 'block';
                setTimeout(() => {
                    this.showWarning = false;
                    document.getElementById('warningAlert').style.display = 'none';
                }, 3000);
            }
            
            spawnPowerup() {
                const types = ['fuel', 'shield', 'score', 'life', 'ammo', 'normal', 'dual', 'laser', 'shotgun', 'bossRift', 'redHeart', 'goldenHeart'];
                const type = types[Math.floor(Math.random() * types.length)];
                const powerup = new Powerup(
                    Math.random() * (this.canvas.width - 100) + 50,
                    Math.random() * (this.canvas.height - 100) + 50,
                    type
                );
                this.powerups.push(powerup);
            }

            spawnShootingAlien() {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(side) {
                    case 0: x = Math.random() * this.canvas.width; y = -50; break;
                    case 1: x = this.canvas.width + 50; y = Math.random() * this.canvas.height; break;
                    case 2: x = Math.random() * this.canvas.width; y = this.canvas.height + 50; break;
                    case 3: x = -50; y = Math.random() * this.canvas.height; break;
                }
                
                const alien = new ShootingAlien(x, y);
                this.shootingAliens.push(alien);
            }

            spawnExplodingAlien() {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(side) {
                    case 0: x = Math.random() * this.canvas.width; y = -50; break;
                    case 1: x = this.canvas.width + 50; y = Math.random() * this.canvas.height; break;
                    case 2: x = Math.random() * this.canvas.width; y = this.canvas.height + 50; break;
                    case 3: x = -50; y = Math.random() * this.canvas.height; break;
                }
                
                const alien = new ExplodingAlien(x, y);
                this.explodingAliens.push(alien);
            }

            spawnMultiplyingAlien() {
                const side = Math.floor(Math.random() * 4);
                let x, y;
                
                switch(side) {
                    case 0: x = Math.random() * this.canvas.width; y = -50; break;
                    case 1: x = this.canvas.width + 50; y = Math.random() * this.canvas.height; break;
                    case 2: x = Math.random() * this.canvas.width; y = this.canvas.height + 50; break;
                    case 3: x = -50; y = Math.random() * this.canvas.height; break;
                }
                
                const alien = new MultiplyingAlien(x, y);
                this.multiplyingAliens.push(alien);
            }
            
            fireWeapon() {
                const currentWeapon = this.weapons[this.currentWeaponIndex];
                if ((this.ammo[currentWeapon] ?? 0) <= 0 && !this.infiniteAmmo) return;
                const cooldown = this.weaponCooldowns[currentWeapon];
                if (cooldown > 0 && !this.rapidFire) return;
                switch(currentWeapon) {
                    case 'normal':
                        this.fireNormal();
                        this.weaponCooldowns.normal = 150; // increased from 90
                        break;
                    case 'dual':
                        this.fireDual();
                        this.weaponCooldowns.dual = 200; // increased from 120
                        break;
                    case 'shotgun':
                        this.fireShotgun();
                        this.weaponCooldowns.shotgun = 350; // increased from 220
                        break;
                }
                this.playSound('shoot');
            }
            
            fireNormal() {
                if (!this.infiniteAmmo) this.ammo.normal--;
                // Calculate bullet spawn position at the front of the spaceship
                const bulletX = this.spaceship.x + Math.cos(this.spaceship.angle) * this.spaceship.size;
                const bulletY = this.spaceship.y + Math.sin(this.spaceship.angle) * this.spaceship.size;
                
                const projectile = new Projectile(
                    bulletX, 
                    bulletY, 
                    this.spaceship.angle,
                    'normal'
                );
                this.projectiles.push(projectile);
            }
            
            fireDual() {
                if (!this.infiniteAmmo) this.ammo.dual -= 2;
                // Calculate bullet spawn positions for dual guns
                const leftBulletX = this.spaceship.x + Math.cos(this.spaceship.angle) * this.spaceship.size + Math.cos(this.spaceship.angle + Math.PI/2) * 8;
                const leftBulletY = this.spaceship.y + Math.sin(this.spaceship.angle) * this.spaceship.size + Math.sin(this.spaceship.angle + Math.PI/2) * 8;
                const rightBulletX = this.spaceship.x + Math.cos(this.spaceship.angle) * this.spaceship.size + Math.cos(this.spaceship.angle - Math.PI/2) * 8;
                const rightBulletY = this.spaceship.y + Math.sin(this.spaceship.angle) * this.spaceship.size + Math.sin(this.spaceship.angle - Math.PI/2) * 8;
                
                // Left gun
                const leftProjectile = new Projectile(
                    leftBulletX, 
                    leftBulletY, 
                    this.spaceship.angle,
                    'dual'
                );
                // Right gun
                const rightProjectile = new Projectile(
                    rightBulletX, 
                    rightBulletY, 
                    this.spaceship.angle,
                    'dual'
                );
                this.projectiles.push(leftProjectile, rightProjectile);
            }
            
            fireLaser() {
                // Laser is continuous, no cooldown needed
                if (!this.laserActive) {
                    this.laserActive = true;
                    this.laserTimer = 0;
                }
            }
            
            drawLaserBeam() {
                if (!this.infiniteAmmo) this.ammo.laser = Math.max(0, this.ammo.laser - 0.5); // Drain ammo slowly
                
                this.laserStartX = this.spaceship.x + Math.cos(this.spaceship.angle) * this.spaceship.size;
                this.laserStartY = this.spaceship.y + Math.sin(this.spaceship.angle) * this.spaceship.size;
                this.laserEndX = this.laserStartX + Math.cos(this.spaceship.angle) * 1000;
                this.laserEndY = this.laserStartY + Math.sin(this.spaceship.angle) * 1000;
                
                const startX = this.laserStartX;
                const startY = this.laserStartY;
                const endX = this.laserEndX;
                const endY = this.laserEndY;
                
                // Draw laser beam with multiple layers for effect
                this.ctx.save();
                
                // Outer glow
                this.ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
                this.ctx.lineWidth = 12;
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Main beam
                this.ctx.strokeStyle = '#ff00ff';
                this.ctx.lineWidth = 8;
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Inner core
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 4;
                this.ctx.beginPath();
                this.ctx.moveTo(startX, startY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Energy particles along the beam
                for (let i = 0; i < 10; i++) {
                    const t = i / 10;
                    const x = startX + (endX - startX) * t;
                    const y = startY + (endY - startY) * t;
                    const offset = (Math.random() - 0.5) * 8;
                    
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(x + offset, y + offset, 2, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            }
            
            fireShotgun() {
                if (!this.infiniteAmmo) this.ammo.shotgun -= 4;
                // Calculate bullet spawn position at the front of the spaceship
                const bulletX = this.spaceship.x + Math.cos(this.spaceship.angle) * this.spaceship.size;
                const bulletY = this.spaceship.y + Math.sin(this.spaceship.angle) * this.spaceship.size;
                
                // Fire 4 bullets with random spread
                for (let i = 0; i < 4; i++) {
                    const spread = (Math.random() - 0.5) * 0.6; // Random spread
                    const projectile = new Projectile(
                        bulletX, 
                        bulletY, 
                        this.spaceship.angle + spread,
                        'shotgun'
                    );
                    this.projectiles.push(projectile);
                }
            }
            
            update(deltaTime) {
                if (this.gameState !== 'playing') return;
                
                // Update combo timer
                this.comboTimer += deltaTime;
                if (this.comboTimer > 3000) { // 3 seconds to maintain combo
                    this.combo = 0;
                    this.comboTimer = 0;
                }
                
                // Update cheat timer
                this.cheatTimer += deltaTime;
                if (this.cheatTimer > 5000) { // 5 seconds to reset cheat input
                    this.cheatInput = '';
                    this.cheatTimer = 0;
                }
                
                // Update weapon cooldowns
                Object.keys(this.weaponCooldowns).forEach(weapon => {
                    this.weaponCooldowns[weapon] = Math.max(0, this.weaponCooldowns[weapon] - deltaTime);
                });
                
                // Handle rapid fire
                if (this.isMouseDown && this.ammo[this.weaponType] > 0) {
                    this.fireWeapon();
                }
                
                // Update spaceship
                this.spaceship.update(deltaTime, this.keys, this.canvas.width, this.canvas.height);
                
                // Fuel decay
                this.fuelDecayTimer += deltaTime;
                if (this.fuelDecayTimer > 1000) {
                    this.fuel = Math.max(0, this.fuel - 1);
                    this.fuelDecayTimer = 0;
                    
                    if (this.fuel <= 0) {
                        this.takeDamage();
                    }
                }
                
                // Update asteroids
                this.asteroids.forEach(asteroid => {
                    asteroid.update(deltaTime, this.spaceship);
                });
                
                // Update aliens
                this.aliens.forEach(alien => {
                    alien.update(deltaTime, this.spaceship, this.canvas.width, this.canvas.height);
                });

                // Update shooting aliens
                this.shootingAliens.forEach(alien => {
                    alien.update(deltaTime, this.spaceship, this.canvas.width, this.canvas.height, this.enemyProjectiles);
                });

                // Update exploding aliens
                this.explodingAliens.forEach((alien, index) => {
                    const result = alien.update(deltaTime, this.spaceship, this.canvas.width, this.canvas.height);
                    if (result === 'explode') {
                        this.createExplosion(alien.x, alien.y, '#ff0000', 50);
                        this.explodingAliens.splice(index, 1);
                        this.takeDamage();
                    }
                });

                // Update multiplying aliens
                this.multiplyingAliens.forEach((alien, index) => {
                    const result = alien.update(deltaTime, this.spaceship, this.canvas.width, this.canvas.height);
                    if (result === 'multiply') {
                        // Spawn smaller aliens
                        for (let i = 0; i < 2; i++) {
                            const smallAlien = new Alien(alien.x + (Math.random() - 0.5) * 40, alien.y + (Math.random() - 0.5) * 40);
                            smallAlien.size = 15;
                            this.aliens.push(smallAlien);
                        }
                    }
                });

                // Update enemy projectiles
                this.enemyProjectiles.forEach(projectile => {
                    projectile.update(deltaTime);
                });
                
                // Update boss
                if (this.bossActive && this.boss) {
                    this.boss.update(deltaTime, this.spaceship, this.canvas.width, this.canvas.height);
                }
                
                // Update powerups
                this.powerups.forEach(powerup => {
                    powerup.update(deltaTime);
                });
                
                // Update projectiles
                this.projectiles.forEach(projectile => {
                    projectile.update(deltaTime, this.aliens);
                });
                
                // Update particles
                this.particles = this.particles.filter(particle => {
                    particle.update(deltaTime);
                    return particle.life > 0;
                });
                
                // Update stars with parallax effect
                this.stars.forEach(star => {
                    star.twinkle += deltaTime * 0.002;
                    star.x -= star.speed * (this.spaceship.vx * 0.1);
                    star.y -= star.speed * (this.spaceship.vy * 0.1);
                    
                    // Wrap stars around screen
                    if (star.x < -10) star.x = this.canvas.width + 10;
                    if (star.x > this.canvas.width + 10) star.x = -10;
                    if (star.y < -10) star.y = this.canvas.height + 10;
                    if (star.y > this.canvas.height + 10) star.y = -10;
                });
                
                // Spawn asteroids (gradual increase with level)
                this.asteroidSpawnTimer += deltaTime;
                const baseSpawnTime = 5000; // Start slower
                const spawnTimeReduction = Math.min(this.level * 200, 3000); // Gradual reduction
                const spawnTime = Math.max(baseSpawnTime - spawnTimeReduction, 2000); // Minimum 2 seconds
                
                if (this.asteroidSpawnTimer > spawnTime) {
                    // Spawn more asteroids as level increases
                    const spawnCount = Math.min(Math.floor(this.level / 2) + 1, 4);
                    for (let i = 0; i < spawnCount; i++) {
                        this.spawnAsteroid();
                    }
                    this.asteroidSpawnTimer = 0;
                }
                
                // Spawn aliens (more gradual)
                this.alienSpawnTimer += deltaTime;
                if (this.alienSpawnTimer > Math.max(25000 - this.level * 800, 12000)) {
                    this.spawnAlien();
                    this.alienSpawnTimer = 0;
                }

                // Spawn shooting aliens (more gradual)
                this.shootingAlienSpawnTimer += deltaTime;
                if (this.shootingAlienSpawnTimer > Math.max(20000 - this.level * 600, 15000)) {
                    this.spawnShootingAlien();
                    this.shootingAlienSpawnTimer = 0;
                }

                // Spawn exploding aliens (more gradual)
                this.explodingAlienSpawnTimer += deltaTime;
                if (this.explodingAlienSpawnTimer > Math.max(30000 - this.level * 1000, 20000)) {
                    this.spawnExplodingAlien();
                    this.explodingAlienSpawnTimer = 0;
                }

                // Spawn multiplying aliens (more gradual)
                this.multiplyingAlienSpawnTimer += deltaTime;
                if (this.multiplyingAlienSpawnTimer > Math.max(35000 - this.level * 1200, 25000)) {
                    this.spawnMultiplyingAlien();
                    this.multiplyingAlienSpawnTimer = 0;
                }
                
                // Spawn powerups (more frequent)
                this.powerupSpawnTimer += deltaTime;
                if (this.powerupSpawnTimer > 8000) { // Reduced from 15000 to 8000 (every 8 seconds)
                    this.spawnPowerup();
                    this.powerupSpawnTimer = 0;
                }
                
                // Check collisions
                this.checkCollisions();
                
                // Update score and level
                this.score += Math.floor(deltaTime * 0.1);
                const newLevel = Math.floor(this.score / 2000) + 1;
                if (newLevel > this.level) {
                    this.level = newLevel;
                    this.showNotification(`LEVEL ${this.level}! THREAT INCREASED!`);
                    
                    // Spawn boss every 5 levels (with cooldown check)
                    if (this.level % 5 === 0 && !this.bossActive) {
                        this.spawnBoss();
                    }
                }
                
                // Clean up objects
                this.cleanupObjects();
                
                this.updateUI();
            }
            
            checkCollisions() {
                // Spaceship vs Asteroids
                this.asteroids.forEach((asteroid, index) => {
                    if (this.spaceship.collidesWith(asteroid)) {
                        // Only shield takes damage from asteroids
                        this.shield = Math.max(0, this.shield - 5); // 5% shield loss
                        this.playSound('hit');
                        this.createExplosion(asteroid.x, asteroid.y);
                        this.asteroids.splice(index, 1);
                    }
                });
                
                // Spaceship vs Aliens
                this.aliens.forEach((alien, index) => {
                    if (this.spaceship.collidesWith(alien)) {
                        if (this.shield > 0) {
                            this.shield = Math.max(0, this.shield - 10); // 10% shield loss
                            this.playSound('hit');
                        } else {
                            this.takeDamage();
                        }
                        
                        this.createExplosion(alien.x, alien.y, '#ff0000');
                        this.aliens.splice(index, 1);
                    }
                });

                // Spaceship vs Shooting Aliens
                this.shootingAliens.forEach((alien, index) => {
                    if (this.spaceship.collidesWith(alien)) {
                        if (this.shield > 0) {
                            this.shield = Math.max(0, this.shield - 10); // 10% shield loss
                            this.playSound('hit');
                        } else {
                            this.takeDamage();
                        }
                        
                        this.createExplosion(alien.x, alien.y, '#ff6600');
                        this.shootingAliens.splice(index, 1);
                    }
                });

                // Spaceship vs Exploding Aliens
                this.explodingAliens.forEach((alien, index) => {
                    if (this.spaceship.collidesWith(alien)) {
                        if (this.shield > 0) {
                            this.shield = Math.max(0, this.shield - 10); // 10% shield loss
                            this.playSound('hit');
                        } else {
                            this.takeDamage();
                        }
                        
                        this.createExplosion(alien.x, alien.y, '#ff0000', 40);
                        this.explodingAliens.splice(index, 1);
                    }
                });

                // Spaceship vs Multiplying Aliens
                this.multiplyingAliens.forEach((alien, index) => {
                    if (this.spaceship.collidesWith(alien)) {
                        if (this.shield > 0) {
                            this.shield = Math.max(0, this.shield - 10); // 10% shield loss
                            this.playSound('hit');
                        } else {
                            this.takeDamage();
                        }
                        
                        this.createExplosion(alien.x, alien.y, '#ff00ff');
                        this.multiplyingAliens.splice(index, 1);
                    }
                });

                // Spaceship vs Enemy Projectiles
                this.enemyProjectiles.forEach((projectile, index) => {
                    if (this.spaceship.collidesWith(projectile)) {
                        if (this.shield > 0) {
                            this.shield = Math.max(0, this.shield - 10); // 10% shield loss
                            this.playSound('hit');
                        } else {
                            this.takeDamage();
                        }
                        
                        this.enemyProjectiles.splice(index, 1);
                    }
                });
                
                // Spaceship vs Powerups
                this.powerups.forEach((powerup, index) => {
                    if (this.spaceship.collidesWith(powerup)) {
                        this.collectPowerup(powerup);
                        this.powerups.splice(index, 1);
                    }
                });
                
                // Projectiles vs Asteroids
                this.projectiles.forEach((projectile, pIndex) => {
                    this.asteroids.forEach((asteroid, aIndex) => {
                        if (projectile.collidesWith(asteroid)) {
                            this.createExplosion(asteroid.x, asteroid.y);
                            this.asteroids.splice(aIndex, 1);
                            this.projectiles.splice(pIndex, 1);
                            this.score += 100;
                        }
                    });
                });
                
                // Projectiles vs Aliens
                this.projectiles.forEach((projectile, pIndex) => {
                    this.aliens.forEach((alien, aIndex) => {
                        if (projectile.collidesWith(alien)) {
                            this.createExplosion(alien.x, alien.y, '#ff0000');
                            this.aliens.splice(aIndex, 1);
                            this.projectiles.splice(pIndex, 1);
                            
                            // Combo system
                            const currentTime = performance.now();
                            if (currentTime - this.lastKillTime < 3000) {
                                this.combo++;
                                this.comboTimer = 0;
                                const comboBonus = this.combo * 100;
                                this.score += 500 + comboBonus;
                                this.showCombo(this.combo, comboBonus);
                            } else {
                                this.combo = 1;
                                this.comboTimer = 0;
                                this.score += 500;
                            }
                            this.lastKillTime = currentTime;
                            this.aliensKilled++;
                            this.showNotification('ALIEN DESTROYED! +500 POINTS');
                            // Reward: +100 ammo for current weapon, +1 life (up to maxLives)
                            this.ammo[this.weaponType] = Math.min(200, (this.ammo[this.weaponType] ?? 0) + 100);
                            this.lives = Math.min(this.maxLives, this.lives + 1);
                            this.updateUI();
                        }
                    });
                });

                // Projectiles vs Shooting Aliens
                this.projectiles.forEach((projectile, pIndex) => {
                    this.shootingAliens.forEach((alien, aIndex) => {
                        if (projectile.collidesWith(alien)) {
                            this.createExplosion(alien.x, alien.y, '#ff6600');
                            this.shootingAliens.splice(aIndex, 1);
                            this.projectiles.splice(pIndex, 1);
                            this.score += 600;
                            this.aliensKilled++;
                            this.showNotification('SHOOTING ALIEN DESTROYED! +600 POINTS');
                            // Reward: +100 ammo for current weapon, +1 life (up to maxLives)
                            this.ammo[this.weaponType] = Math.min(200, (this.ammo[this.weaponType] ?? 0) + 100);
                            this.lives = Math.min(this.maxLives, this.lives + 1);
                            this.updateUI();
                        }
                    });
                });

                // Projectiles vs Exploding Aliens
                this.projectiles.forEach((projectile, pIndex) => {
                    this.explodingAliens.forEach((alien, aIndex) => {
                        if (projectile.collidesWith(alien)) {
                            this.createExplosion(alien.x, alien.y, '#ff0000', 40);
                            this.explodingAliens.splice(aIndex, 1);
                            this.projectiles.splice(pIndex, 1);
                            this.score += 700;
                            this.aliensKilled++;
                            this.showNotification('EXPLODING ALIEN DESTROYED! +700 POINTS');
                            // Reward: +100 ammo for current weapon, +1 life (up to maxLives)
                            this.ammo[this.weaponType] = Math.min(200, (this.ammo[this.weaponType] ?? 0) + 100);
                            this.lives = Math.min(this.maxLives, this.lives + 1);
                            this.updateUI();
                        }
                    });
                });

                // Projectiles vs Multiplying Aliens
                this.projectiles.forEach((projectile, pIndex) => {
                    this.multiplyingAliens.forEach((alien, aIndex) => {
                        if (projectile.collidesWith(alien)) {
                            this.createExplosion(alien.x, alien.y, '#ff00ff');
                            this.multiplyingAliens.splice(aIndex, 1);
                            this.projectiles.splice(pIndex, 1);
                            
                            // Spawn smaller aliens when multiplying alien is destroyed
                            for (let i = 0; i < 3; i++) {
                                const smallAlien = new Alien(alien.x + (Math.random() - 0.5) * 50, alien.y + (Math.random() - 0.5) * 50);
                                smallAlien.size = 12;
                                this.aliens.push(smallAlien);
                            }
                            
                            this.score += 800;
                            this.aliensKilled++;
                            this.showNotification('MULTIPLYING ALIEN DESTROYED! +800 POINTS');
                            // Reward: +100 ammo for current weapon, +1 life (up to maxLives)
                            this.ammo[this.weaponType] = Math.min(200, (this.ammo[this.weaponType] ?? 0) + 100);
                            this.lives = Math.min(this.maxLives, this.lives + 1);
                            this.updateUI();
                        }
                    });
                });
                
                // Projectiles vs Boss
                if (this.bossActive && this.boss) {
                    this.projectiles.forEach((projectile, pIndex) => {
                        if (projectile.collidesWith(this.boss)) {
                            if (this.boss.takeDamage(projectile.damage)) {
                                // Boss defeated
                                this.createExplosion(this.boss.x, this.boss.y, '#ff0000', 50);
                                this.score += 5000;
                                this.showNotification('BOSS DEFEATED! +5000 POINTS!');
                                this.bossActive = false;
                                this.boss = null;
                                document.getElementById('bossHealth').style.display = 'none';
                                // Only spawn next boss if game is still playing
                                if (this.gameState === 'playing') {
                                    setTimeout(() => {
                                        if (this.gameState === 'playing' && !this.bossActive) {
                                            this.spawnBoss();
                                        }
                                    }, 3000);
                                }
                            }
                            this.projectiles.splice(pIndex, 1);
                        }
                    });
                }
            }
            
            collectPowerup(powerup) {
                this.playSound('powerup');
                switch(powerup.type) {
                    case 'fuel':
                        this.fuel = Math.min(100, this.fuel + 30);
                        this.showNotification('FUEL RESTORED!');
                        break;
                    case 'shield':
                        this.shield = 100;
                        this.showNotification('SHIELD RESTORED TO 100%!');
                        break;
                    case 'score':
                        this.score += 800;
                        this.showNotification('+800 POINTS!');
                        break;
                    case 'life':
                        this.lives = Math.min(5, this.lives + 1);
                        this.showNotification('EXTRA LIFE!');
                        break;
                    case 'ammo':
                        // Refill all ammo types
                        Object.keys(this.ammo).forEach(type => {
                            this.ammo[type] = Math.min(200, this.ammo[type] + 50);
                        });
                        this.showNotification('ALL AMMO REPLENISHED!');
                        break;
                    case 'normal':
                    case 'dual':
                    case 'shotgun':
                        // Add weapon to available weapons if not already present
                        if (!this.weapons.includes(powerup.type)) {
                            this.weapons.push(powerup.type);
                            this.showNotification(`NEW WEAPON UNLOCKED: ${powerup.type.toUpperCase()}!`);
                        } else {
                            this.ammo[powerup.type] = Math.min(200, this.ammo[powerup.type] + 30);
                            this.showNotification(`${powerup.type.toUpperCase()} AMMO +30!`);
                        }
                        break;
                    case 'bossRift':
                        this.spawnBoss();
                        this.showNotification('BOSS RIFT ACTIVATED! PREPARE FOR BATTLE!');
                        break;
                    case 'redHeart':
                        this.lives = Math.min(15, this.lives + 1);
                        this.showNotification('RED HEART! +1 HEALTH!');
                        break;
                    case 'goldenHeart':
                        this.maxLives = (this.maxLives || 10) + 10;
                        this.lives = Math.min(this.maxLives, 20);
                        this.showNotification('GOLDEN HEART! +10 HEALTH & +10 MAX HEALTH!');
                        this.updateUI && this.updateUI();
                        break;
                }
            }
            
            takeDamage() {
                if (this.godMode) {
                    this.showNotification('GOD MODE: NO DAMAGE TAKEN!');
                    return;
                }
                
                this.playSound('hit');
                this.lives--;
                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    this.fuel = 100;
                    this.shield = 25;
                    Object.keys(this.ammo).forEach(type => {
                        this.ammo[type] = Math.min(200, this.ammo[type] + 20);
                    });
                    this.showNotification('SHIP DAMAGED! EMERGENCY SUPPLIES ACTIVATED!');
                }
            }
            
            createExplosion(x, y, color = '#ff8800', particleCount = 25) {
                for (let i = 0; i < particleCount; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
                this.playSound('explosion');
            }
            
            showNotification(text) {
                const notification = document.getElementById('powerupNotification');
                notification.textContent = text;
                notification.style.display = 'block';
                setTimeout(() => {
                    notification.style.display = 'none';
                }, 2000);
            }
            
            showBossWarning(bossName, bossColor) {
                // Create boss warning element
                let bossWarning = document.getElementById('bossWarning');
                if (!bossWarning) {
                    bossWarning = document.createElement('div');
                    bossWarning.id = 'bossWarning';
                    bossWarning.style.cssText = `
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(0, 0, 0, 0.9);
                        border: 3px solid ${bossColor};
                        border-radius: 15px;
                        padding: 30px 50px;
                        text-align: center;
                        z-index: 1000;
                        font-family: 'Courier New', monospace;
                        font-weight: bold;
                        box-shadow: 0 0 50px ${bossColor};
                        animation: bossWarningPulse 2s ease-in-out;
                    `;
                    document.body.appendChild(bossWarning);
                }
                
                bossWarning.style.borderColor = bossColor;
                bossWarning.style.boxShadow = `0 0 50px ${bossColor}`;
                bossWarning.innerHTML = `
                    <div style="color: ${bossColor}; font-size: 2.5rem; margin-bottom: 15px; text-shadow: 0 0 20px ${bossColor};">
                        ⚠️ BOSS DETECTED ⚠️
                    </div>
                    <div style="color: ${bossColor}; font-size: 1.8rem; margin-bottom: 10px; text-shadow: 0 0 15px ${bossColor};">
                        ${bossName}
                    </div>
                    <div style="color: #ffffff; font-size: 1.2rem;">
                        STAGE ${this.bossStage} - PREPARE FOR BATTLE!
                    </div>
                `;
                
                bossWarning.style.display = 'block';
                
                // Add CSS animation if not already present
                if (!document.getElementById('bossWarningStyles')) {
                    const style = document.createElement('style');
                    style.id = 'bossWarningStyles';
                    style.textContent = `
                        @keyframes bossWarningPulse {
                            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Hide after 3 seconds
                setTimeout(() => {
                    bossWarning.style.display = 'none';
                }, 3000);
            }
            
            showCombo(combo, bonus) {
                const comboCounter = document.getElementById('comboCounter');
                comboCounter.textContent = `${combo}x COMBO! +${bonus}`;
                comboCounter.style.display = 'block';
                setTimeout(() => {
                    comboCounter.style.display = 'none';
                }, 1500);
            }
            
            togglePause() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                    document.getElementById('pauseMenu').style.display = 'block';
                    // Pause background music
                    if (this.backgroundMusic) {
                        this.backgroundMusic.pause();
                    }
                } else if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                    document.getElementById('pauseMenu').style.display = 'none';
                    // Resume background music
                    if (this.backgroundMusic) {
                        this.backgroundMusic.play().catch(e => console.log('Music resume blocked'));
                    }
                }
            }
            
            gameOver() {
                this.gameState = 'gameOver';
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalLevel').textContent = this.level;
                document.getElementById('aliensKilled').textContent = this.aliensKilled;
                document.getElementById('gameOver').style.display = 'block';
                
                // Stop background music
                if (this.backgroundMusic) {
                    this.backgroundMusic.pause();
                    this.backgroundMusic.currentTime = 0;
                }
            }
            
            restart() {
                this.gameState = 'playing';
                this.gameMode = 'normal';
                this.score = 0;
                this.level = 1;
                this.lives = 10;
                this.maxLives = 10;
                this.fuel = 100;
                this.shield = 100; // Start with full shield
                this.ammo = { normal: 100, dual: 100, shotgun: 100 };
                this.weaponType = 'normal';
                this.aliensKilled = 0;
                this.combo = 0;
                this.comboTimer = 0;
                this.lastKillTime = 0;
                this.bossActive = false;
                this.boss = null;
                
                // Reset cheat states
                this.godMode = false;
                this.infiniteAmmo = false;
                this.rapidFire = false;
                
                // Restore original functions if they exist
                if (this.originalSpawnFunctions) {
                    this.spawnInitialObjects = this.originalSpawnFunctions.spawnInitialObjects;
                    this.spawnAsteroid = this.originalSpawnFunctions.spawnAsteroid;
                    this.spawnAlien = this.originalSpawnFunctions.spawnAlien;
                    this.spawnShootingAlien = this.originalSpawnFunctions.spawnShootingAlien;
                    this.spawnExplodingAlien = this.originalSpawnFunctions.spawnExplodingAlien;
                    this.spawnMultiplyingAlien = this.originalSpawnFunctions.spawnMultiplyingAlien;
                    this.spawnPowerup = this.originalSpawnFunctions.spawnPowerup;
                }
                
                // Restore original render function if it exists
                if (this.originalRender) {
                    this.render = this.originalRender;
                }
                
                this.spaceship = new Spaceship(this.canvas.width / 2, this.canvas.height / 2, this.selectedSpaceship);
                this.asteroids = [];
                this.aliens = [];
                this.shootingAliens = [];
                this.explodingAliens = [];
                this.multiplyingAliens = [];
                this.powerups = [];
                this.particles = [];
                this.projectiles = [];
                this.enemyProjectiles = [];
                
                this.asteroidSpawnTimer = 0;
                this.alienSpawnTimer = 0;
                this.powerupSpawnTimer = 0;
                this.fuelDecayTimer = 0;
                
                this.spawnInitialObjects();
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('warningAlert').style.display = 'none';
                document.getElementById('pauseMenu').style.display = 'none';
                document.getElementById('bossHealth').style.display = 'none';
                document.getElementById('gameUI').style.display = 'block';
                
                // Restart background music
                if (this.backgroundMusic) {
                    this.backgroundMusic.currentTime = 0;
                    this.backgroundMusic.play().catch(e => console.log('Music restart blocked'));
                }
            }
            
            cleanupObjects() {
                // Remove off-screen objects
                this.asteroids = this.asteroids.filter(asteroid => 
                    asteroid.x > -100 && asteroid.x < this.canvas.width + 100 &&
                    asteroid.y > -100 && asteroid.y < this.canvas.height + 100
                );
                
                this.aliens = this.aliens.filter(alien => 
                    alien.x > -100 && alien.x < this.canvas.width + 100 &&
                    alien.y > -100 && alien.y < this.canvas.height + 100
                );

                this.shootingAliens = this.shootingAliens.filter(alien => 
                    alien.x > -100 && alien.x < this.canvas.width + 100 &&
                    alien.y > -100 && alien.y < this.canvas.height + 100
                );

                this.explodingAliens = this.explodingAliens.filter(alien => 
                    alien.x > -100 && alien.x < this.canvas.width + 100 &&
                    alien.y > -100 && alien.y < this.canvas.height + 100
                );

                this.multiplyingAliens = this.multiplyingAliens.filter(alien => 
                    alien.x > -100 && alien.x < this.canvas.width + 100 &&
                    alien.y > -100 && alien.y < this.canvas.height + 100
                );

                this.enemyProjectiles = this.enemyProjectiles.filter(projectile => 
                    projectile.x > -50 && projectile.x < this.canvas.width + 50 &&
                    projectile.y > -50 && projectile.y < this.canvas.height + 50 &&
                    projectile.life > 0
                );
                
                this.powerups = this.powerups.filter(powerup => powerup.life > 0);
                
                this.projectiles = this.projectiles.filter(projectile => 
                    projectile.x > -50 && projectile.x < this.canvas.width + 50 &&
                    projectile.y > -50 && projectile.y < this.canvas.height + 50 &&
                    projectile.life > 0
                );
            }
            
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('fuel').textContent = Math.floor(this.fuel);
                document.getElementById('shield').textContent = Math.floor(this.shield);
                document.getElementById('alienCount').textContent = this.aliens.length;
                document.getElementById('combo').textContent = this.combo;
                
                // Update weapon display
                this.updateWeaponDisplay();
                
                // Update boss health bar
                if (this.bossActive && this.boss) {
                    const healthPercent = (this.boss.health / this.boss.maxHealth) * 100;
                    document.getElementById('bossHealthBar').style.width = healthPercent + '%';
                }
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw stars
                this.stars.forEach(star => {
                    this.ctx.save();
                    this.ctx.globalAlpha = star.brightness * (0.5 + 0.5 * Math.sin(star.twinkle));
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.beginPath();
                    this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
                
                // Draw spaceship
                this.spaceship.draw(this.ctx);
                
                // Draw asteroids
                this.asteroids.forEach(asteroid => {
                    asteroid.draw(this.ctx);
                });
                
                // Draw aliens
                this.aliens.forEach(alien => {
                    alien.draw(this.ctx);
                });

                // Draw shooting aliens
                this.shootingAliens.forEach(alien => {
                    alien.draw(this.ctx);
                });

                // Draw exploding aliens
                this.explodingAliens.forEach(alien => {
                    alien.draw(this.ctx);
                });

                // Draw multiplying aliens
                this.multiplyingAliens.forEach(alien => {
                    alien.draw(this.ctx);
                });

                // Draw enemy projectiles
                this.enemyProjectiles.forEach(projectile => {
                    projectile.draw(this.ctx);
                });
                
                // Draw powerups
                this.powerups.forEach(powerup => {
                    powerup.draw(this.ctx);
                });
                
                // Draw projectiles
                this.projectiles.forEach(projectile => {
                    projectile.draw(this.ctx);
                });
                

                
                // Draw particles
                this.particles.forEach(particle => {
                    particle.draw(this.ctx);
                });
                
                // Draw boss
                if (this.bossActive && this.boss) {
                    this.boss.draw(this.ctx);
                }
                

            }
            

            
            gameLoop() {
                const currentTime = performance.now();
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.render();
                
                requestAnimationFrame(() => this.gameLoop());
            }

            setGameMode(mode) {
                // Store original spawn functions if not already stored
                if (!this.originalSpawnFunctions) {
                    this.originalSpawnFunctions = {
                        spawnInitialObjects: this.spawnInitialObjects.bind(this),
                        spawnAsteroid: this.spawnAsteroid.bind(this),
                        spawnAlien: this.spawnAlien.bind(this),
                        spawnShootingAlien: this.spawnShootingAlien.bind(this),
                        spawnExplodingAlien: this.spawnExplodingAlien.bind(this),
                        spawnMultiplyingAlien: this.spawnMultiplyingAlien.bind(this),
                        spawnPowerup: this.spawnPowerup.bind(this)
                    };
                }

                this.gameMode = mode;
                
                if (mode === 'freeRoam') {
                    this.asteroids = [];
                    this.aliens = [];
                    this.shootingAliens = [];
                    this.explodingAliens = [];
                    this.multiplyingAliens = [];
                    this.powerups = [];
                    this.bossActive = false;
                    this.boss = null;
                    this.spawnInitialObjects = () => {};
                    this.spawnAsteroid = () => {};
                    this.spawnAlien = () => {};
                    this.spawnShootingAlien = () => {};
                    this.spawnExplodingAlien = () => {};
                    this.spawnMultiplyingAlien = () => {};
                    this.spawnPowerup = () => {};
                    this.showNotification('FREE ROAM MODE ACTIVATED! Press ESC to return to normal mode.');
                } else if (mode === 'onlyAsteroids') {
                    this.aliens = [];
                    this.shootingAliens = [];
                    this.explodingAliens = [];
                    this.multiplyingAliens = [];
                    this.powerups = [];
                    this.bossActive = false;
                    this.boss = null;
                    this.spawnAlien = () => {};
                    this.spawnShootingAlien = () => {};
                    this.spawnExplodingAlien = () => {};
                    this.spawnMultiplyingAlien = () => {};
                    this.spawnPowerup = () => {};
                    this.showNotification('ASTEROIDS ONLY MODE! Press ESC to return to normal mode.');
                } else if (mode === 'onlyAliens') {
                    this.asteroids = [];
                    this.spawnAsteroid = () => {};
                    this.showNotification('ALIENS ONLY MODE! Press ESC to return to normal mode.');
                } else if (mode === 'bossMode') {
                    this.asteroids = [];
                    this.aliens = [];
                    this.shootingAliens = [];
                    this.explodingAliens = [];
                    this.multiplyingAliens = [];
                    this.spawnAsteroid = () => {};
                    this.spawnAlien = () => {};
                    this.spawnShootingAlien = () => {};
                    this.spawnExplodingAlien = () => {};
                    this.spawnMultiplyingAlien = () => {};
                    this.bossActive = false;
                    this.boss = null;
                    this.spawnBoss();
                    this.powerupSpawnTimer = 0;
                    this.spawnPowerup = () => {
                        for (let i = 0; i < 5; i++) {
                            const types = ['fuel', 'shield', 'score', 'life', 'ammo', 'normal', 'dual', 'laser', 'shotgun'];
                            const type = types[Math.floor(Math.random() * types.length)];
                            const powerup = new Powerup(
                                Math.random() * (this.canvas.width - 100) + 50,
                                Math.random() * (this.canvas.height - 100) + 50,
                                type
                            );
                            this.powerups.push(powerup);
                        }
                    };
                    this.showNotification('BOSS MODE ACTIVATED! Press ESC to return to normal mode.');
                } else if (mode === 'showcase') {
                    this.showShowcase();
                } else if (mode === 'normal') {
                    // Restore original spawn functions
                    this.spawnInitialObjects = this.originalSpawnFunctions.spawnInitialObjects;
                    this.spawnAsteroid = this.originalSpawnFunctions.spawnAsteroid;
                    this.spawnAlien = this.originalSpawnFunctions.spawnAlien;
                    this.spawnShootingAlien = this.originalSpawnFunctions.spawnShootingAlien;
                    this.spawnExplodingAlien = this.originalSpawnFunctions.spawnExplodingAlien;
                    this.spawnMultiplyingAlien = this.originalSpawnFunctions.spawnMultiplyingAlien;
                    this.spawnPowerup = this.originalSpawnFunctions.spawnPowerup;
                    this.showNotification('RETURNED TO NORMAL MODE!');
                }
            }

            showShowcase() {
                this.gameState = 'showcase';
                this.gameMode = 'showcase';
                this.renderShowcase = true;
                this.showNotification('SHOWCASE MODE! Press ESC to return to normal mode.');
                
                // Store original render function
                if (!this.originalRender) {
                    this.originalRender = this.render.bind(this);
                }
                
                this.render = () => {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Draw background stars
                    this.stars.forEach(star => {
                        this.ctx.save();
                        this.ctx.globalAlpha = star.brightness * (0.5 + 0.5 * Math.sin(star.twinkle));
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.beginPath();
                        this.ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.restore();
                    });
                    
                    // Draw title
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.font = '48px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('GAME ASSETS SHOWCASE', this.canvas.width / 2, 80);
                    
                    // Spaceships
                    for (let i = 0; i < 5; i++) {
                        let img = new Image();
                        img.src = `spaceships/spaceship${i+1}.png`;
                        this.ctx.save();
                        this.ctx.translate(150 + i * 150, 150);
                        this.ctx.drawImage(img, -50, -50, 100, 100);
                        this.ctx.restore();
                    }
                    
                    // Alien types
                    for (let i = 0; i < 4; i++) {
                        let img = new Image();
                        img.src = 'aliens/alien.png';
                        this.ctx.save();
                        this.ctx.translate(150 + i * 150, 350);
                        this.ctx.drawImage(img, -40, -40, 80, 80);
                        this.ctx.restore();
                    }
                    
                    // Asteroid
                    this.ctx.save();
                    this.ctx.translate(150, 550);
                    this.ctx.fillStyle = '#888888';
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 40, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                    
                    // Boss
                    let bossImg = new Image();
                    bossImg.src = 'boss.png';
                    this.ctx.save();
                    this.ctx.translate(600, 550);
                    this.ctx.drawImage(bossImg, -60, -60, 120, 120);
                    this.ctx.restore();
                    
                    // Instructions
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '24px Courier New';
                    this.ctx.fillText('Press ESC to return to normal mode', this.canvas.width / 2, this.canvas.height - 50);
                };
            }

            showRollingCredits() {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('gameUI').style.display = 'none';
                document.getElementById('spaceshipSelect').style.display = 'none';
                document.getElementById('weaponSelect').style.display = 'none';
                document.getElementById('credits').style.display = 'none';
                
                // Stop background music and play Star Wars theme
                if (this.backgroundMusic) {
                    this.backgroundMusic.pause();
                }
                const starWarsTheme = new Audio('starwars.mp3');
                starWarsTheme.volume = 0.5;
                starWarsTheme.play().catch(e => console.log('Star Wars theme autoplay blocked'));
                
                let creditsDiv = document.getElementById('rollingCredits');
                if (!creditsDiv) {
                    creditsDiv = document.createElement('div');
                    creditsDiv.id = 'rollingCredits';
                    creditsDiv.style.position = 'absolute';
                    creditsDiv.style.top = '0';
                    creditsDiv.style.left = '0';
                    creditsDiv.style.width = '100%';
                    creditsDiv.style.height = '100%';
                    creditsDiv.style.background = 'radial-gradient(ellipse at center, #0a0a1a 0%, #1a1a2e 20%, #16213e 40%, #0f0f23 60%, #0a1026 80%, #000000 100%), linear-gradient(135deg, rgba(120, 0, 255, 0.1) 0%, rgba(0, 255, 200, 0.1) 25%, rgba(255, 0, 150, 0.1) 50%, rgba(0, 170, 255, 0.1) 75%, rgba(255, 0, 255, 0.1) 100%)';
                    creditsDiv.style.overflow = 'hidden';
                    creditsDiv.style.zIndex = '9999';
                    creditsDiv.innerHTML = `
                        <div id="starWarsCredits" style="position: absolute; bottom: -100%; width: 100%; text-align: center; color: #00ff88; font-family: 'Courier New', monospace;">
                            <h1 style="font-size: 5rem; margin-bottom: 60px; text-shadow: 0 0 40px #00ff88;">VOID DRIFTERS</h1>
                            <p style="font-size: 1.8rem; margin-bottom: 40px; color: #fff; max-width: 900px; margin-left: auto; margin-right: auto;">This game was built out of sheer curiosity, a keyboard, and an unreasonable amount of caffeine. It's an indie project packed with drifting spaceships, hostile aliens, explosive powerups, and boss fights that may or may not have been over-engineered for no reason.</p>
                            <p style="font-size: 1.5rem; margin-bottom: 40px; color: #fff; max-width: 800px; margin-left: auto; margin-right: auto;">I'm Sinhal Joshi, a passionate programmer with no clear goal and way too much free time. I like building things that serve absolutely no practical purpose—but are a blast to mess with anyway.</p>
                            <p style="font-size: 1.3rem; margin-bottom: 40px; color: #fff; max-width: 800px; margin-left: auto; margin-right: auto;">If you're into unpredictable, wildly unnecessary, and often chaotic digital experiments, you'll probably enjoy the rest of my project portfolio too.</p>
                            <div style="text-align: center; margin-bottom: 40px;">
                                <div style="font-size: 2.5rem; color: #00ff88; margin-bottom: 20px; text-shadow: 0 0 30px #00ff88; font-weight: bold;">AURA+++++</div>
                                <img src="sinhal.png" style="width: 300px; height: auto; filter: drop-shadow(0 0 50px #00ff88) drop-shadow(0 0 100px #00ffcc) drop-shadow(0 0 150px #00ffff); animation: auraPulse 3s ease-in-out infinite;" />
                            </div>
                            <div style="font-size: 1.2rem; color: #fff; margin-bottom: 30px;">Connect with the creator:</div>
                            <div style="margin-bottom: 60px;">
                                <a href="https://github.com/Zephyr4772" target="_blank" style="color: #00ff88; font-size: 2rem; margin: 0 30px; text-decoration: none;">GitHub</a>
                                <a href="https://www.linkedin.com/in/sinhal-joshi-244603275/" target="_blank" style="color: #00ff88; font-size: 2rem; margin: 0 30px; text-decoration: none;">LinkedIn</a>
                            </div>
                            <div style="font-size: 1.5rem; color: #fff; margin-bottom: 100px;">May the drift be with you!</div>
                        </div>
                    `;
                    document.body.appendChild(creditsDiv);
                } else {
                    creditsDiv.style.display = 'block';
                }
                let credits = document.getElementById('starWarsCredits');
                credits.style.transition = 'none';
                credits.style.bottom = '-100%';
                setTimeout(() => {
                    credits.style.transition = 'bottom 60s linear'; // increased from 30s to 60s
                    credits.style.bottom = '100%';
                }, 100);
                setTimeout(() => {
                    creditsDiv.style.display = 'none';
                    // Stop Star Wars theme and resume background music
                    starWarsTheme.pause();
                    if (this.backgroundMusic) {
                        this.backgroundMusic.play().catch(e => console.log('Background music resume blocked'));
                    }
                    this.showMainMenu();
                }, 62000); // increased from 22000 to 62000 to match the new duration
            }

        }
        
        class Spaceship {
            constructor(x, y, spaceshipImage = 'spaceship.png') {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.angle = 0;
                this.size = 32; // Increased from 25 for all spaceships
                this.maxSpeed = 3; // toned down from 5
                this.thrustPower = 0.25; // toned down from 0.4
                this.drag = 0.99; // increased drag for smoother movement
                this.thrustParticleTimer = 0;
                
                // Load spaceship image
                this.image = new Image();
                this.image.src = spaceshipImage;
                this.imageLoaded = false;
                this.image.onload = () => {
                    this.imageLoaded = true;
                    console.log('Spaceship image loaded:', spaceshipImage);
                };
                this.image.onerror = () => {
                    console.error('Failed to load spaceship image:', spaceshipImage);
                };
            }
            
            update(deltaTime, keys, canvasWidth, canvasHeight) {
                // Handle input
                let thrustX = 0;
                let thrustY = 0;
                
                if (keys['w'] || keys['arrowup']) thrustY -= this.thrustPower;
                if (keys['s'] || keys['arrowdown']) thrustY += this.thrustPower;
                if (keys['a'] || keys['arrowleft']) thrustX -= this.thrustPower;
                if (keys['d'] || keys['arrowright']) thrustX += this.thrustPower;
                
                // Thruster boost (Shift key)
                if (keys['shift']) {
                    thrustX *= 2.0; // reduced from 3.0
                    thrustY *= 2.0; // reduced from 3.0
                }
                
                // Apply thrust
                this.vx += thrustX;
                this.vy += thrustY;
                
                // Apply drag
                this.vx *= this.drag;
                this.vy *= this.drag;
                
                // Limit speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > this.maxSpeed) {
                    this.vx = (this.vx / speed) * this.maxSpeed;
                    this.vy = (this.vy / speed) * this.maxSpeed;
                }
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Calculate angle based on velocity direction
                if (speed > 0.1) {
                    this.angle = Math.atan2(this.vy, this.vx);
                }
                
                // Wrap around screen
                if (this.x < 0) this.x = canvasWidth;
                if (this.x > canvasWidth) this.x = 0;
                if (this.y < 0) this.y = canvasHeight;
                if (this.y > canvasHeight) this.y = 0;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Draw engine exhaust glow
                ctx.fillStyle = 'rgba(255, 136, 0, 0.6)';
                ctx.beginPath();
                ctx.ellipse(-this.size - 5, 0, 8, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.imageLoaded) {
                    // Draw spaceship image with 90-degree rotation to face forward
                    ctx.rotate(Math.PI / 2); // Rotate 90 degrees
                    ctx.drawImage(this.image, -this.size, -this.size, this.size * 2, this.size * 2);
                } else {
                    // Fallback to geometric design
                    // Draw main body (cockpit)
                    ctx.fillStyle = '#00aaff';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 0.8, this.size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw cockpit window
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.ellipse(this.size * 0.3, 0, this.size * 0.4, this.size * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw nose cone
                    ctx.fillStyle = '#00ff88';
                    ctx.beginPath();
                    ctx.moveTo(this.size, 0);
                    ctx.lineTo(this.size * 0.6, -this.size * 0.4);
                    ctx.lineTo(this.size * 0.6, this.size * 0.4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw wings
                    ctx.fillStyle = '#0088ff';
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size * 0.8);
                    ctx.lineTo(-this.size * 0.5, -this.size * 0.6);
                    ctx.lineTo(-this.size * 0.3, -this.size * 0.2);
                    ctx.lineTo(0, -this.size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, this.size * 0.8);
                    ctx.lineTo(-this.size * 0.5, this.size * 0.6);
                    ctx.lineTo(-this.size * 0.3, this.size * 0.2);
                    ctx.lineTo(0, this.size * 0.3);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw engine housing
                    ctx.fillStyle = '#444444';
                    ctx.beginPath();
                    ctx.ellipse(-this.size * 0.8, 0, this.size * 0.4, this.size * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw engine glow
                    ctx.fillStyle = '#ff4400';
                    ctx.beginPath();
                    ctx.ellipse(-this.size, 0, this.size * 0.3, this.size * 0.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw spaceship outline
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            collidesWith(object) {
                const dx = this.x - object.x;
                const dy = this.y - object.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                // Adjust collision detection for larger sizes
                const collisionDistance = (this.size + object.size) * 0.8;
                return distance < collisionDistance;
            }
        }
        
        class Asteroid {
            constructor(x, y, level = 1) {
                this.x = x;
                this.y = y;
                // Speed increases with level
                const baseSpeed = 2.5; // reduced from 4
                const speedMultiplier = 1 + (level - 1) * 0.2; // reduced from 0.3
                this.vx = (Math.random() - 0.5) * baseSpeed * speedMultiplier;
                this.vy = (Math.random() - 0.5) * baseSpeed * speedMultiplier;
                this.size = Math.random() * 20 + 10;
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                this.vertices = [];
                this.level = level;
                
                // Generate random polygon vertices
                const numVertices = Math.floor(Math.random() * 4) + 6;
                for (let i = 0; i < numVertices; i++) {
                    const angle = (i / numVertices) * Math.PI * 2;
                    const radius = this.size * (0.7 + Math.random() * 0.3);
                    this.vertices.push({
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                }
            }
            
            update(deltaTime, spaceship) {
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;
                
                // Simple AI: move towards spaceship slightly (increases with level)
                const dx = spaceship.x - this.x;
                const dy = spaceship.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0) {
                    const aiStrength = 0.01 + (this.level - 1) * 0.005;
                    this.vx += (dx / distance) * aiStrength;
                    this.vy += (dy / distance) * aiStrength;
                }
                
                // Limit speed (increases with level)
                const maxSpeed = 2 + (this.level - 1) * 0.3; // reduced from 3 + 0.5
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > maxSpeed) {
                    this.vx = (this.vx / speed) * maxSpeed;
                    this.vy = (this.vy / speed) * maxSpeed;
                }
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                ctx.fillStyle = '#888888';
                ctx.beginPath();
                ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                for (let i = 1; i < this.vertices.length; i++) {
                    ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#666666';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.restore();
            }
        }
        
        class Alien {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2; // reduced from 3
                this.vy = (Math.random() - 0.5) * 2; // reduced from 3
                this.size = 25; // Increased from 20
                this.angle = 0;
                this.pulseTimer = 0;
                
                // Load alien image
                this.image = new Image();
                this.image.src = 'aliens/alien.png';
                this.imageLoaded = false;
                this.image.onload = () => {
                    this.imageLoaded = true;
                };
            }
            
            update(deltaTime, spaceship, canvasWidth, canvasHeight) {
                // Move towards spaceship
                const dx = spaceship.x - this.x;
                const dy = spaceship.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    this.vx += (dx / distance) * 0.03; // reduced from 0.05
                    this.vy += (dy / distance) * 0.03; // reduced from 0.05
                }
                
                // Limit speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 3) { // reduced from 4
                    this.vx = (this.vx / speed) * 3; // reduced from 4
                    this.vy = (this.vy / speed) * 3; // reduced from 4
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.angle += 0.03; // reduced from 0.1
                this.pulseTimer += deltaTime;
                
                // Wrap around screen
                if (this.x < 0) this.x = canvasWidth;
                if (this.x > canvasWidth) this.x = 0;
                if (this.y < 0) this.y = canvasHeight;
                if (this.y > canvasHeight) this.y = 0;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                const pulse = 0.8 + 0.2 * Math.sin(this.pulseTimer * 0.01);
                
                // Draw energy field glow
                ctx.fillStyle = `rgba(255, 0, 0, ${pulse * 0.3})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 1.2, this.size * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.imageLoaded) {
                    // Draw alien image
                    ctx.drawImage(this.image, -this.size, -this.size, this.size * 2, this.size * 2);
                } else {
                    // Fallback to geometric design
                    // Draw main body (dark core)
                    ctx.fillStyle = '#660000';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 0.8, this.size * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw alien body (red armor)
                    ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw armor plates
                    ctx.fillStyle = '#880000';
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.8, -this.size * 0.3);
                    ctx.lineTo(-this.size * 0.4, -this.size * 0.4);
                    ctx.lineTo(-this.size * 0.2, -this.size * 0.2);
                    ctx.lineTo(-this.size * 0.6, -this.size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.8, this.size * 0.3);
                    ctx.lineTo(-this.size * 0.4, this.size * 0.4);
                    ctx.lineTo(-this.size * 0.2, this.size * 0.2);
                    ctx.lineTo(-this.size * 0.6, this.size * 0.1);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw alien eyes (glowing)
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(-this.size * 0.4, -this.size * 0.2, 4, 0, Math.PI * 2);
                    ctx.arc(this.size * 0.4, -this.size * 0.2, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(-this.size * 0.4, -this.size * 0.2, 2, 0, Math.PI * 2);
                    ctx.arc(this.size * 0.4, -this.size * 0.2, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw energy core
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw weapon ports
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-this.size * 0.6, 0, 2, 0, Math.PI * 2);
                    ctx.arc(this.size * 0.6, 0, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        class ShootingAlien {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 1.5; // reduced from 2
                this.vy = (Math.random() - 0.5) * 1.5; // reduced from 2
                this.size = 23; // Increased from 18
                this.angle = 0;
                this.pulseTimer = 0;
                this.shootTimer = 0;
                this.shootCooldown = 2000;
                
                // Load alien image
                this.image = new Image();
                this.image.src = 'aliens/alien.png';
                this.imageLoaded = false;
                this.image.onload = () => {
                    this.imageLoaded = true;
                };
            }
            
            update(deltaTime, spaceship, canvasWidth, canvasHeight, enemyProjectiles) {
                // Move towards spaceship
                const dx = spaceship.x - this.x;
                const dy = spaceship.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    this.vx += (dx / distance) * 0.02; // reduced from 0.03
                    this.vy += (dy / distance) * 0.02; // reduced from 0.03
                }
                
                // Limit speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 2.5) { // reduced from 3
                    this.vx = (this.vx / speed) * 2.5; // reduced from 3
                    this.vy = (this.vy / speed) * 2.5; // reduced from 3
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.angle += 0.025; // reduced from 0.08
                this.pulseTimer += deltaTime;
                this.shootTimer += deltaTime;
                
                // Shoot at player
                if (this.shootTimer > this.shootCooldown && distance < 300) {
                    const angle = Math.atan2(dy, dx);
                    const projectile = new EnemyProjectile(this.x, this.y, angle);
                    enemyProjectiles.push(projectile);
                    this.shootTimer = 0;
                }
                
                // Wrap around screen
                if (this.x < 0) this.x = canvasWidth;
                if (this.x > canvasWidth) this.x = 0;
                if (this.y < 0) this.y = canvasHeight;
                if (this.y > canvasHeight) this.y = 0;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                const pulse = 0.8 + 0.2 * Math.sin(this.pulseTimer * 0.01);
                
                // Draw energy field glow
                ctx.fillStyle = `rgba(255, 102, 0, ${pulse * 0.4})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 1.3, this.size * 0.9, 0, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.imageLoaded) {
                    // Draw alien image with orange tint
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.fillStyle = 'rgba(255, 102, 0, 0.3)';
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.drawImage(this.image, -this.size, -this.size, this.size * 2, this.size * 2);
                } else {
                    // Fallback design
                    ctx.fillStyle = `rgba(255, 102, 0, ${pulse})`;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw weapon barrels
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(-this.size * 0.7, 0, 3, 0, Math.PI * 2);
                    ctx.arc(this.size * 0.7, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        class ExplodingAlien {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2.5; // reduced from 4
                this.vy = (Math.random() - 0.5) * 2.5; // reduced from 4
                this.size = 28; // Increased from 22
                this.angle = 0;
                this.pulseTimer = 0;
                this.explosionTimer = 0;
                this.explosionRadius = 0;
                this.maxExplosionRadius = 100;
                
                // Load alien image
                this.image = new Image();
                this.image.src = 'aliens/alien.png';
                this.imageLoaded = false;
                this.image.onload = () => {
                    this.imageLoaded = true;
                };
            }
            
            update(deltaTime, spaceship, canvasWidth, canvasHeight) {
                // Move towards spaceship more aggressively
                const dx = spaceship.x - this.x;
                const dy = spaceship.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    this.vx += (dx / distance) * 0.05; // reduced from 0.08
                    this.vy += (dy / distance) * 0.05; // reduced from 0.08
                }
                
                // Limit speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 3.5) { // reduced from 5
                    this.vx = (this.vx / speed) * 3.5; // reduced from 5
                    this.vy = (this.vy / speed) * 3.5; // reduced from 5
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.angle += 0.04; // reduced from 0.12
                this.pulseTimer += deltaTime;
                
                // Explode when close to player
                if (distance < 80) {
                    this.explosionTimer += deltaTime;
                    this.explosionRadius = (this.explosionTimer / 500) * this.maxExplosionRadius;
                    
                    if (this.explosionTimer > 500) {
                        // Create massive explosion
                        return 'explode';
                    }
                }
                
                // Wrap around screen
                if (this.x < 0) this.x = canvasWidth;
                if (this.x > canvasWidth) this.x = 0;
                if (this.y < 0) this.y = canvasHeight;
                if (this.y > canvasHeight) this.y = 0;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                const pulse = 0.7 + 0.3 * Math.sin(this.pulseTimer * 0.02);
                
                // Draw explosion radius if exploding
                if (this.explosionTimer > 0) {
                    ctx.strokeStyle = `rgba(255, 0, 0, ${1 - this.explosionTimer / 500})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.explosionRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Draw energy field glow
                ctx.fillStyle = `rgba(255, 0, 0, ${pulse * 0.5})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 1.4, this.size * 1.0, 0, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.imageLoaded) {
                    // Draw alien image with red tint
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.drawImage(this.image, -this.size, -this.size, this.size * 2, this.size * 2);
                } else {
                    // Fallback design
                    ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw explosive core
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        class MultiplyingAlien {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 2; // reduced from 3
                this.vy = (Math.random() - 0.5) * 2; // reduced from 3
                this.size = 25; // Increased from 20
                this.angle = 0;
                this.pulseTimer = 0;
                this.multiplyTimer = 0;
                this.multiplyCooldown = 8000;
                
                // Load alien image
                this.image = new Image();
                this.image.src = 'aliens/alien.png';
                this.imageLoaded = false;
                this.image.onload = () => {
                    this.imageLoaded = true;
                };
            }
            
            update(deltaTime, spaceship, canvasWidth, canvasHeight) {
                // Move in erratic pattern
                const dx = spaceship.x - this.x;
                const dy = spaceship.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    this.vx += (dx / distance) * 0.02;
                    this.vy += (dy / distance) * 0.02;
                }
                
                // Add some randomness
                this.vx += (Math.random() - 0.5) * 0.1;
                this.vy += (Math.random() - 0.5) * 0.1;
                
                // Limit speed
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > 3) { // reduced from 4
                    this.vx = (this.vx / speed) * 3; // reduced from 4
                    this.vy = (this.vy / speed) * 3; // reduced from 4
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.angle += 0.05; // reduced from 0.15
                this.pulseTimer += deltaTime;
                this.multiplyTimer += deltaTime;
                
                // Multiply when timer is up
                if (this.multiplyTimer > this.multiplyCooldown) {
                    this.multiplyTimer = 0;
                    return 'multiply';
                }
                
                // Wrap around screen
                if (this.x < 0) this.x = canvasWidth;
                if (this.x > canvasWidth) this.x = 0;
                if (this.y < 0) this.y = canvasHeight;
                if (this.y > canvasHeight) this.y = 0;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                const pulse = 0.6 + 0.4 * Math.sin(this.pulseTimer * 0.015);
                
                // Draw energy field glow
                ctx.fillStyle = `rgba(255, 0, 255, ${pulse * 0.4})`;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size * 1.3, this.size * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.imageLoaded) {
                    // Draw alien image with purple tint
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.fillStyle = 'rgba(255, 0, 255, 0.3)';
                    ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.drawImage(this.image, -this.size, -this.size, this.size * 2, this.size * 2);
                } else {
                    // Fallback design
                    ctx.fillStyle = `rgba(255, 0, 255, ${pulse})`;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw multiplication symbols
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('×', 0, 4);
                }
                
                ctx.restore();
            }
        }
        
        class EnemyProjectile {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 4; // reduced from 6
                this.size = 4;
                this.life = 3000;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
            }
            
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= deltaTime;
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Draw enemy projectile
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                ctx.restore();
            }
            
            collidesWith(object) {
                const dx = this.x - object.x;
                const dy = this.y - object.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < this.size + object.size;
            }
        }
        
        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.size = 18;
                this.life = 10000; // 10 seconds
                this.angle = 0;
                this.pulseTimer = 0;
            }
            
            update(deltaTime) {
                this.life -= deltaTime;
                this.angle += 0.05;
                this.pulseTimer += deltaTime;
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                const pulse = 0.5 + 0.5 * Math.sin(this.pulseTimer * 0.01);
                
                // Draw powerup based on type
                switch(this.type) {
                    case 'fuel':
                        ctx.fillStyle = `rgba(0, 255, 0, ${pulse})`;
                        break;
                    case 'shield':
                        ctx.fillStyle = `rgba(0, 255, 255, ${pulse})`;
                        break;
                    case 'score':
                        ctx.fillStyle = `rgba(255, 255, 0, ${pulse})`;
                        break;
                    case 'life':
                        ctx.fillStyle = `rgba(255, 0, 255, ${pulse})`;
                        break;
                    case 'ammo':
                        ctx.fillStyle = `rgba(255, 128, 0, ${pulse})`;
                        break;
                    case 'normal':
                        ctx.fillStyle = `rgba(0, 170, 255, ${pulse})`;
                        break;
                    case 'dual':
                        ctx.fillStyle = `rgba(0, 255, 136, ${pulse})`;
                        break;
                    case 'laser':
                        ctx.fillStyle = `rgba(255, 0, 255, ${pulse})`;
                        break;
                    case 'shotgun':
                        ctx.fillStyle = `rgba(255, 136, 0, ${pulse})`;
                        break;
                    case 'bossRift':
                        ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                        // Draw rift effect
                        ctx.strokeStyle = `rgba(255, 0, 0, ${pulse})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * 2, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * 1.5, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'redHeart':
                        ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                        break;
                    case 'goldenHeart':
                        ctx.fillStyle = `rgba(255, 215, 0, ${pulse})`;
                        // Draw golden glow
                        ctx.strokeStyle = `rgba(255, 215, 0, ${pulse})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * 1.5, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw powerup symbol
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                let symbol = '';
                switch(this.type) {
                    case 'fuel': symbol = 'F'; break;
                    case 'shield': symbol = 'S'; break;
                    case 'score': symbol = '$'; break;
                    case 'life': symbol = '♥'; break;
                    case 'ammo': symbol = 'A'; break;
                    case 'normal': symbol = 'N'; break;
                    case 'dual': symbol = 'D'; break;
                    case 'laser': symbol = 'L'; break;
                    case 'shotgun': symbol = 'G'; break;
                    case 'bossRift': symbol = '⚡'; break;
                    case 'redHeart': symbol = '♥'; break;
                    case 'goldenHeart': symbol = '💛'; break;
                }
                
                ctx.fillText(symbol, 0, 0);
                
                ctx.restore();
            }
        }
        
        class Projectile {
            constructor(x, y, angle, type) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.type = type;
                this.speed = this.getSpeed(type);
                this.size = this.getSize(type);
                this.life = 3000; // 3 seconds
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.damage = this.getDamage(type);
                this.target = null;
            }
            
            getSpeed(type) {
                switch(type) {
                    case 'normal': return 10; // reduced from 15
                    case 'dual': return 9; // reduced from 14
                    case 'shotgun': return 7; // reduced from 10
                    default: return 8; // reduced from 12
                }
            }
            
            getSize(type) {
                switch(type) {
                    case 'normal': return 4;
                    case 'dual': return 3;
                    case 'shotgun': return 2;
                    default: return 3;
                }
            }
            
            getDamage(type) {
                switch(type) {
                    case 'normal': return 15;
                    case 'dual': return 12;
                    case 'shotgun': return 8;
                    default: return 15;
                }
            }
            
            update(deltaTime, aliens = []) {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= deltaTime;
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Neon rectangle/cylinder bullet
                let color = '#00eaff', glow = '#00eaff';
                if (this.type === 'normal') { color = '#fff'; glow = '#00eaff'; }
                else if (this.type === 'dual') { color = '#00ff88'; glow = '#00ffcc'; }
                else if (this.type === 'shotgun') { color = '#fff700'; glow = '#fff700'; }
                // Glow
                ctx.shadowColor = glow;
                ctx.shadowBlur = 18;
                // Draw rounded rectangle (length 24, width 6, radius 3)
                const w = 24, h = 6, r = 3;
                ctx.beginPath();
                ctx.moveTo(-w/2 + r, -h/2);
                ctx.lineTo(w/2 - r, -h/2);
                ctx.quadraticCurveTo(w/2, -h/2, w/2, -h/2 + r);
                ctx.lineTo(w/2, h/2 - r);
                ctx.quadraticCurveTo(w/2, h/2, w/2 - r, h/2);
                ctx.lineTo(-w/2 + r, h/2);
                ctx.quadraticCurveTo(-w/2, h/2, -w/2, h/2 - r);
                ctx.lineTo(-w/2, -h/2 + r);
                ctx.quadraticCurveTo(-w/2, -h/2, -w/2 + r, -h/2);
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.92;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            }
            
            collidesWith(object) {
                const dx = this.x - object.x;
                const dy = this.y - object.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < this.size + object.size;
            }
        }
        
        class Boss {
            constructor(x, y, level, bossStage = 1) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 1; // reduced from 2
                this.size = 60 + bossStage * 5;
                this.health = 150 + (level - 1) * 50 + bossStage * 100;
                this.maxHealth = this.health;
                this.angle = 0;
                this.attackTimer = 0;
                this.attackCooldown = Math.max(1200, 3000 - (level - 1) * 150 - bossStage * 300);
                this.phase = 0;
                this.phaseTimer = 0;
                this.rageMode = false;
                this.rageTimer = 0;
                this.teleportTimer = 0;
                this.teleportCooldown = Math.max(2000, 5000 - bossStage * 500);
                this.shieldActive = bossStage >= 2;
                this.shieldTimer = 0;
                // Boss patterns grow with stage
                this.attackPatterns = ['spread', 'laser'];
                if (bossStage >= 2) this.attackPatterns.push('spiral');
                if (bossStage >= 3) this.attackPatterns.push('missile');
                if (bossStage >= 4) this.attackPatterns.push('minions');
                if (bossStage >= 5) this.attackPatterns.push('rage');
                this.currentPattern = 0;
                this.bossStage = bossStage;
                
                // Load boss image
                this.image = new Image();
                this.image.src = 'boss.png';
                this.imageLoaded = false;
                this.image.onload = () => {
                    this.imageLoaded = true;
                    console.log('Boss image loaded successfully');
                };
                this.image.onerror = () => {
                    console.error('Failed to load boss image, using fallback');
                    this.imageLoaded = false;
                };
            }
            
            clampToScreen(canvasWidth, canvasHeight) {
                // Keep boss within visible area (with margin for its size)
                const margin = this.size + 20;
                this.x = Math.max(margin, Math.min(canvasWidth - margin, this.x));
                this.y = Math.max(margin, Math.min(canvasHeight - margin, this.y));
            }
            
            update(deltaTime, spaceship, canvasWidth, canvasHeight) {
                this.x += this.vx;
                this.y += this.vy;
                this.angle += 0.02;
                this.attackTimer += deltaTime;
                this.phaseTimer += deltaTime;
                this.teleportTimer += deltaTime;
                this.shieldTimer += deltaTime;
                
                // Rage mode when health is low
                if (this.health < this.maxHealth * 0.2 && !this.rageMode) {
                    this.rageMode = true;
                    this.attackCooldown *= 0.7; // Less aggressive rage mode
                }
                
                // Move in a pattern
                if (this.y < 100) {
                    this.vy = 1;
                } else {
                    this.vy = 0;
                    this.vx = Math.sin(this.phaseTimer * 0.001) * (this.rageMode ? 2.5 : 1.5); // reduced from 4:2
                }
                
                // Clamp boss position to screen
                this.clampToScreen(canvasWidth, canvasHeight);
                
                // Teleport when timer is up (less frequent)
                if (this.teleportTimer > this.teleportCooldown * 1.5) {
                    this.teleport(canvasWidth, canvasHeight);
                    this.teleportTimer = 0;
                }
                
                // Shield activation
                if (this.shieldTimer > 8000) {
                    this.shieldActive = !this.shieldActive;
                    this.shieldTimer = 0;
                }
                
                // Attack pattern
                if (this.attackTimer > this.attackCooldown) {
                    this.attack(spaceship);
                    this.attackTimer = 0;
                    this.currentPattern = (this.currentPattern + 1) % this.attackPatterns.length;
                }
                
                // Phase changes
                if (this.phaseTimer > 15000) { // Every 15 seconds
                    this.phase = (this.phase + 1) % 4;
                    this.phaseTimer = 0;
                }
            }
            
            teleport(canvasWidth, canvasHeight) {
                // Teleport to a random position within the visible area (with margin)
                const margin = this.size + 20;
                this.x = Math.random() * (canvasWidth - 2 * margin) + margin;
                this.y = Math.random() * ((canvasHeight / 2) - margin) + margin;
                this.clampToScreen(canvasWidth, canvasHeight);
            }
            
            attack(spaceship) {
                const pattern = this.attackPatterns[this.currentPattern];
                
                switch(pattern) {
                    case 'spread':
                        // Spread shot - fewer projectiles in a fan
                        for (let i = 0; i < 3 + this.bossStage; i++) {
                            const angle = Math.atan2(spaceship.y - this.y, spaceship.x - this.x) + (i - 1) * 0.4; // Wider spread
                            const projectile = new BossProjectile(this.x, this.y, angle, 'spread');
                            // Add to game's enemy projectiles array
                            if (window.game) {
                                window.game.enemyProjectiles.push(projectile);
                            }
                        }
                        break;
                    case 'laser':
                        // Powerful laser beam
                        const laserAngle = Math.atan2(spaceship.y - this.y, spaceship.x - this.x);
                        const projectile = new BossProjectile(this.x, this.y, laserAngle, 'laser');
                        if (window.game) {
                            window.game.enemyProjectiles.push(projectile);
                        }
                        break;
                    case 'missile':
                        // Homing missile
                        const missileAngle = Math.atan2(spaceship.y - this.y, spaceship.x - this.x);
                        const missile = new BossProjectile(this.x, this.y, missileAngle, 'missile');
                        if (window.game) {
                            window.game.enemyProjectiles.push(missile);
                        }
                        break;
                    case 'spiral':
                        // Spiral pattern - fewer projectiles
                        for (let i = 0; i < 5 + this.bossStage; i++) {
                            const angle = this.angle + (i / (5 + this.bossStage)) * Math.PI * 2;
                            const spiralProjectile = new BossProjectile(this.x, this.y, angle, 'spiral');
                            if (window.game) {
                                window.game.enemyProjectiles.push(spiralProjectile);
                            }
                        }
                        break;
                    case 'minions':
                        // Spawn minions (aliens)
                        if (window.game) {
                            for (let i = 0; i < this.bossStage; i++) {
                                const minion = new Alien(this.x + Math.random()*100-50, this.y + Math.random()*100-50);
                                window.game.aliens.push(minion);
                            }
                        }
                        break;
                    case 'rage':
                        // Combo of all attacks
                        this.attackPatterns.forEach(pat => {
                            if (pat !== 'rage') this.currentPattern = this.attackPatterns.indexOf(pat), this.attack(spaceship);
                        });
                        break;
                }
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Visual effects by stage
                if (this.bossStage >= 1) {
                    // Subtle glow
                    ctx.shadowColor = '#00eaff';
                    ctx.shadowBlur = 20 + this.bossStage * 5;
                }
                if (this.bossStage >= 2) {
                    // Brighter, colored aura
                    ctx.save();
                    ctx.globalAlpha = 0.25 + 0.05 * this.bossStage;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 1.3, 0, Math.PI * 2);
                    ctx.fillStyle = this.bossStage === 2 ? '#00eaff' : (this.bossStage === 3 ? '#ff00ff' : (this.bossStage === 4 ? '#ff8800' : '#ffff00'));
                    ctx.filter = 'blur(8px)';
                    ctx.fill();
                    ctx.restore();
                }
                if (this.bossStage >= 3) {
                    // Pulsing outline
                    ctx.save();
                    const pulse = 0.7 + 0.3 * Math.sin(Date.now() / 200);
                    ctx.globalAlpha = 0.5 * pulse;
                    ctx.lineWidth = 8;
                    ctx.strokeStyle = '#00eaff';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                if (this.bossStage >= 4) {
                    // Flashing/animated aura
                    ctx.save();
                    const flash = 0.5 + 0.5 * Math.sin(Date.now() / 100);
                    ctx.globalAlpha = 0.3 * flash;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 1.7, 0, Math.PI * 2);
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 10;
                    ctx.setLineDash([10, 10]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.restore();
                }
                if (this.bossStage >= 5) {
                    // Intense multi-color glow and pulsing
                    ctx.save();
                    const t = Date.now() / 300;
                    for (let i = 0; i < 3; i++) {
                        ctx.globalAlpha = 0.25;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * (1.8 + 0.1 * i), 0, Math.PI * 2);
                        ctx.strokeStyle = `hsl(${(t * 60 + i * 120) % 360}, 100%, 60%)`;
                        ctx.lineWidth = 12 - i * 3;
                        ctx.stroke();
                    }
                    ctx.restore();
                }

                // Draw shield if active
                if (this.shieldActive) {
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                if (this.imageLoaded) {
                    // Draw boss image
                    ctx.drawImage(this.image, -this.size, -this.size, this.size * 2, this.size * 2);
                    
                    // Apply health-based tinting
                    const healthPercent = this.health / this.maxHealth;
                    if (healthPercent < 0.5) {
                        // Red tint when health is low
                        ctx.globalCompositeOperation = 'multiply';
                        ctx.fillStyle = `rgba(255, 0, 0, ${0.3 * (1 - healthPercent)})`;
                        ctx.fillRect(-this.size, -this.size, this.size * 2, this.size * 2);
                        ctx.globalCompositeOperation = 'source-over';
                    }
                    
                    // Rage mode glow effect
                    if (this.rageMode) {
                        ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * 1.1, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                } else {
                    // Fallback to geometric design if image fails to load
                    const healthPercent = this.health / this.maxHealth;
                    const red = Math.floor(255 * (1 - healthPercent));
                    const green = Math.floor(255 * healthPercent);
                    ctx.fillStyle = `rgb(${red}, ${green}, 0)`;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw boss details
                    ctx.strokeStyle = this.rageMode ? '#ffff00' : '#ffffff';
                    ctx.lineWidth = this.rageMode ? 5 : 3;
                    ctx.stroke();
                    
                    // Draw weapon systems
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(-this.size * 0.6, 0, 8, 0, Math.PI * 2);
                    ctx.arc(this.size * 0.6, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw phase indicator
                    const phaseColors = ['#ffff00', '#00ffff', '#ff00ff', '#ff8800'];
                    ctx.fillStyle = phaseColors[this.phase];
                    ctx.beginPath();
                    ctx.arc(0, -this.size * 0.8, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw rage mode indicator
                    if (this.rageMode) {
                        ctx.strokeStyle = '#ffff00';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * 1.2, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                
                ctx.restore();
            }
            
            takeDamage(damage) {
                if (this.shieldActive) {
                    damage *= 0.3; // Shield reduces damage by 70%
                }
                this.health -= damage;
                if (this.health <= 0) {
                    return true; // Boss defeated
                }
                return false;
            }
        }
        
        class BossProjectile {
            constructor(x, y, angle, type) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.type = type;
                this.speed = this.getSpeed(type);
                this.size = this.getSize(type);
                this.life = 5000;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.damage = this.getDamage(type);
                this.homing = type === 'missile';
                this.target = null;
                this.trail = [];
            }
            
            getSpeed(type) {
                switch(type) {
                    case 'laser': return 5; // reduced from 8
                    case 'missile': return 4; // reduced from 6
                    case 'spiral': return 3; // reduced from 4
                    default: return 5; // reduced from 7
                }
            }
            
            getSize(type) {
                switch(type) {
                    case 'laser': return 6;
                    case 'missile': return 8;
                    case 'spiral': return 4;
                    default: return 5;
                }
            }
            
            getDamage(type) {
                switch(type) {
                    case 'laser': return 25; // Reduced damage
                    case 'missile': return 30; // Reduced damage
                    case 'spiral': return 15; // Reduced damage
                    default: return 20; // Reduced damage
                }
            }
            
            update(deltaTime) {
                // Update trail
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 10) {
                    this.trail.shift();
                }
                
                this.x += this.vx;
                this.y += this.vy;
                this.life -= deltaTime;
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Draw trail
                this.trail.forEach((pos, index) => {
                    const alpha = index / this.trail.length;
                    ctx.fillStyle = `rgba(255, 0, 0, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(pos.x - this.x, pos.y - this.y, this.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                switch(this.type) {
                    case 'laser':
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        break;
                    case 'missile':
                        ctx.fillStyle = '#ff8800';
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'spiral':
                        ctx.fillStyle = '#ff00ff';
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    default:
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                
                ctx.restore();
            }
            
            collidesWith(object) {
                const dx = this.x - object.x;
                const dy = this.y - object.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < this.size + object.size;
            }
        }
        
        class Particle {
            constructor(x, y, color = '#ff8800') {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 1000;
                this.maxLife = 1000;
                this.size = Math.random() * 4 + 2;
                this.color = color;
            }
            
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= deltaTime;
            }
            
            draw(ctx) {
                if (this.life <= 0) return;
                
                const alpha = this.life / this.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Initialize the game immediately when page loads
        window.addEventListener('load', () => {
            window.game = new Game();
            createMenuBackground();
        });
        
        function createMenuBackground() {
            const menuBackground = document.querySelector('.menuBackground');
            if (!menuBackground) return;
            
            // Create floating asteroids (game-style)
            for (let i = 0; i < 12; i++) {
                const asteroid = document.createElement('div');
                asteroid.className = 'floatingAsteroid';
                
                // Create polygon vertices for realistic asteroid shape
                const numVertices = Math.floor(Math.random() * 4) + 6;
                const size = Math.random() * 25 + 15;
                let polygonPoints = '';
                
                for (let j = 0; j < numVertices; j++) {
                    const angle = (j / numVertices) * Math.PI * 2;
                    const radius = size * (0.7 + Math.random() * 0.3);
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    polygonPoints += `${x},${y} `;
                }
                
                asteroid.style.cssText = `
                    position: absolute;
                    width: ${size * 2}px;
                    height: ${size * 2}px;
                    background: #ffe6e6;
                    clip-path: polygon(${polygonPoints});
                    opacity: 0.5;
                    left: ${Math.random() * 100}%;
                    top: ${Math.random() * 100}%;
                    animation: floatAsteroid ${Math.random() * 20 + 15}s linear infinite;
                    animation-delay: ${Math.random() * 10}s;
                    z-index: 1;
                    pointer-events: none;
                    transform-origin: center;
                `;
                menuBackground.appendChild(asteroid);
            }
            
            // Create floating aliens (increased count)
            for (let i = 0; i < 15; i++) {
                const alien = document.createElement('div');
                alien.className = 'floatingAlien';
                alien.innerHTML = '👽';
                alien.style.cssText = `
                    position: absolute;
                    font-size: ${Math.random() * 25 + 12}px;
                    opacity: 0.4;
                    left: ${Math.random() * 100}%;
                    top: ${Math.random() * 100}%;
                    animation: floatAlien ${Math.random() * 25 + 20}s linear infinite;
                    animation-delay: ${Math.random() * 15}s;
                    z-index: 1;
                    pointer-events: none;
                    filter: drop-shadow(0 0 5px rgba(255, 0, 0, 0.3));
                `;
                menuBackground.appendChild(alien);
            }
            
            // Add CSS animations
            const style = document.createElement('style');
            style.textContent = `
                @keyframes floatAsteroid {
                    0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
                    10% { opacity: 0.5; }
                    90% { opacity: 0.5; }
                    100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
                }
                
                @keyframes floatAlien {
                    0% { transform: translateY(100vh) rotate(0deg) scale(1); opacity: 0; }
                    10% { opacity: 0.4; }
                    50% { transform: translateY(50vh) rotate(180deg) scale(1.2); opacity: 0.4; }
                    90% { opacity: 0.4; }
                    100% { transform: translateY(-100px) rotate(360deg) scale(1); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
        }

        // Start button event listener
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!window.game) window.game = new Game();
            window.game.startGame();
        });

        // Global cheat system
        let globalCheatInput = '';
        let globalCheatTimer = 0;

        window.addEventListener('keydown', (e) => {
            globalCheatInput += e.key.toLowerCase();
            globalCheatTimer = 0;

            if (globalCheatInput.includes('lore')) {
                if (typeof game !== 'undefined' && game.showRollingCredits) {
                    game.showRollingCredits();
                }
                globalCheatInput = '';
            }

            if (globalCheatInput.includes('cheat')) {
                document.getElementById('cheatMenu').style.display = 'flex';
                globalCheatInput = '';
            }

            if (globalCheatInput.length > 20) globalCheatInput = '';
        });

        // Reset input if idle for too long
        setInterval(() => {
            globalCheatTimer += 100;
            if (globalCheatTimer > 5000) globalCheatInput = '';
        }, 100);


    </script>
</body>
</html>